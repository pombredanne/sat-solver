<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>satsolver: How the SAT solver works</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>How the SAT solver works </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="theory"></a>
Theory</h2>
<p>CNF - Conjunktive Normal Form</p>
<p>Boolean expression of the form (x|y) &amp; (-a|b|c) &amp; ... a,b,c,x,y are LITERALS There a positive literals (x,y) and negative literals (-a, -b) Terms in parentheses are CLAUSES</p>
<p>Goal: Make the whole expression TRUE</p>
<p>Useful shortcuts:</p>
<ul>
<li>If a positive literal goes TRUE within a clause, the whole clause is TRUE</li>
<li>If a negative literal goes FALSE within a clause, the whole clause is TRUE</li>
</ul>
<h2><a class="anchor" id="datastruct"></a>
Data structure</h2>
<div class="fragment"><pre class="fragment">  <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a> p;                 <span class="comment">/* first literal in rule */</span>
  <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a> d;                 <span class="comment">/* Id offset into &#39;list of providers */</span>
                        <span class="comment">/* terminated by 0&#39; as used by whatprovides; pool-&gt;whatprovides + d */</span>
                        <span class="comment">/* in case of binary rules, d == 0, w1 == p, w2 == other literal */</span>
                        <span class="comment">/* in case of disabled rules: ~d, aka -d - 1 */</span>
  <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a> w1, w2;            <span class="comment">/* watches, literals not-yet-decided */</span>
                        <span class="comment">/* if !w2, assertion, not rule */</span>
  <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a> n1, n2;            <span class="comment">/* next rules in linked list, corresponding to w1,w2 */</span>


    r-&gt;n1 = solv-&gt;watches[nsolvables + r-&gt;w1];
    solv-&gt;watches[nsolvables + r-&gt;w1] = r - solv-&gt;rules;
            
    r-&gt;n2 = solv-&gt;watches[nsolvables + r-&gt;w2];
    solv-&gt;watches[nsolvables + r-&gt;w2] = r - solv-&gt;rules;
</pre></div><div class="fragment"><pre class="fragment"> Assertion
  keepinstalled (A), install 
   p=A, d=0, w1=p, w2=0
  uninstallable (-A), <span class="keyword">remove</span>
   p=-A, d=0, w1=p, w2=0

 Binary <a class="code" href="HowItWorks_8doc.html#ac23ed37ca0d07e4f7dccf4251ad0ccd8">rules</a>:
   (A|B)
   p=A, d=0, w1=p, w2=B
   (-A|B)
   p=-A, d=0, w1=p, w2=B

 A requires B : !A | provider1(B) | provider2(B)
   p=-A, d=&lt;whatprovides_offset&gt;, w1=, w2=
 
 B updates A : A | provider1(B) | provider2(B)
   p=A, d=&lt;whatprovides_offset&gt;, w1=, w2=
 

 A conflicts B : (!A | !provider1(B)) &amp; (!A | !provider2(B)) ...
   p=-A, d=-B1, w1=, w2=
   p=-A, d=-B2, w1=, w2=
   p=-A, d=-B3, w1=, w2=
   ...

 &#39;not&#39; is encoded as a negative <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a>


Action        | p  | d       | w1    | w2
--------------+----+---------+-------+--------
Assert A      | A  | 0       | A     | 0
Assert -A     |-A  | 0       |-A     | 0
Binary A,B    | A  | 0       | A     | B
Binary -A,B   |-A  | 0       |-A     | B
A requires B  |-A  | prov(B) |-A     | whatprovidesdata(B)
B updates A   | A  | prov(B) | A     | whatprovidesdata(B)
A conflicts B |-A  | -B      |-A     |-B

addrule(p, d)
</pre></div><div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> add rule</span>
<span class="comment">  p = direct literal; always &lt; 0 for installed rpm rules</span>
<span class="comment">  d, if &lt; 0 direct literal, if &gt; 0 offset into whatprovides, if == 0 rule is assertion (look at p only)</span>
<span class="comment"></span>
<span class="comment"></span>
<span class="comment"> A requires b, b provided by B1,B2,B3 =&gt; (-A|B1|B2|B3)</span>
<span class="comment"></span>
<span class="comment"> p &lt; 0 : pkg id of A</span>
<span class="comment"> d &gt; 0 : Offset in whatprovidesdata (list of providers of b)</span>
<span class="comment"></span>
<span class="comment"> A conflicts b, b provided by B1,B2,B3 =&gt; (-A|-B1), (-A|-B2), (-A|-B3)</span>
<span class="comment"> p &lt; 0 : pkg id of A</span>
<span class="comment"> d &lt; 0 : Id of solvable (e.g. B1)</span>
<span class="comment"></span>
<span class="comment"> d == 0: unary rule, assertion =&gt; (A) or (-A)</span>
<span class="comment"></span>
<span class="comment">   Install:    p &gt; 0, d = 0   (A)             user requested install</span>
<span class="comment">   Remove:     p &lt; 0, d = 0   (-A)            user requested remove</span>
<span class="comment">   Requires:   p &lt; 0, d &gt; 0   (-A|B1|B2|...)  d: &lt;list of providers for requirement of p&gt;</span>
<span class="comment">   Updates:    p &gt; 0, d &gt; 0   (A|B1|B2|...)   d: &lt;list of updates for solvable p&gt;</span>
<span class="comment">   Conflicts:  p &lt; 0, d &lt; 0   (-A|-B1),(-A|-B2),...         either p (conflict issuer) or d (conflict provider) (binary rule)</span>
<span class="comment">   Obsoletes:  p &lt; 0, d &lt; 0   (-A|-B1),(-A|-B2),...     A: uninstalled, Bx = provider of obsoletes</span>
<span class="comment">   Learnt:     p &gt; 0, d &lt; 0   (A|-B)</span>
<span class="comment">   No-op:      p = 0, d = 0   (null)          (used as policy rule placeholder)</span>
<span class="comment">   install one of:  p =-SYS, d &gt; 0</span>
<span class="comment"></span>
<span class="comment">   resulting watches:</span>
<span class="comment">   ------------------</span>
<span class="comment">   Direct assertion (no watch needed)( if d &lt;0 ) --&gt; d = 0, w1 = p, w2 = 0</span>
<span class="comment">   Binary rule: p = first literal, d = 0, w2 = second literal, w1 = p</span>
<span class="comment">   every other : w1 = p, w2 = whatprovidesdata[d];</span>
<span class="comment">   Disabled rule: d &lt; 0, w1 = 0</span>
<span class="comment"></span>
<span class="comment">   always returns a rule for non-rpm rules</span>
<span class="comment">*/</span>
</pre></div><p>enablerule: if (d &lt; 0): d = -d - 1 disablerule if (d &gt;= 0): d = -d - 1</p>
<h3><a class="anchor" id="watches"></a>
Watches</h3>
<p>Watches are usually on literals that are not FALSE (either TRUE or UNDEF) Execept: If one watch is on a TRUE (set first), the other can be on a FALSE (set later). This is useful on a backtrack.</p>
<p>Watches 'link' rules involving the same literal Only for n-ary (n &gt;= 2) rules, not for assertions</p>
<p>Watches start at solv-&gt;watches[nsolvables]</p>
<p>watches[nsolvables+s] == rule installing s (aka A, B, C,... in CNF clause) watches[nsolvables-s] == rule removing s (aka -A, -B, -C, ... in CNF clause)</p>
<p>'watches trigger when literal goes false'</p>
<p>watches[A] = rule involving A rule-&gt;n1 = next rule involving A watches[B] = rule involving B rule-&gt;n2 = next rule involving B</p>
<h3><a class="anchor" id="propag"></a>
Propagation</h3>
<p>This distributes decisions among affected rules and checks that rules evaluate to 'true'.</p>
<p>Since rules are in CNF (conjunctive normal form), it is sufficient for one sub-term (x or y in x|y) to become 'true'.</p>
<p>The interesting case is a 'false' sub-term (x or y in x|y) because this requires the 'other' side to become true.</p>
<h3><a class="anchor" id="iterat"></a>
Iterating over installed</h3>
<p>The pool marks the minimum and maximum Id of installed solvables. There might be other (non-installed) solvables in-between.</p>
<h2><a class="anchor" id="algo"></a>
Algorithm</h2>
<ul>
<li>set up rules for installed packages if (installed) foreach(installed): addrpmrulesforsolvable convert dependencies of solvable into rules run through the complete graph of dependencies spawned the solvable foreach(installed): addrpmrulesforupdaters add rules to allow updates: A | upates(A)</li>
</ul>
<ul>
<li>set up rules for solvables mentioned in job foreach (install request) addrpmrulesforsolvable foreach (update request) addrpmrulesforupdaters /* dont look at removals </li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Oct 17 2010 15:21:23 for satsolver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
