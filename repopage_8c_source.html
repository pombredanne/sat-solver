<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>satsolver: src/repopage.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_4422304925a660d7ad9b44d0ebab103c.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>repopage.c</h1>  </div>
</div>
<div class="contents">
<a href="repopage_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2007-2008, Novell Inc.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * This program is licensed under the BSD license, read LICENSE.BSD</span>
<a name="l00005"></a>00005 <span class="comment"> * for further information</span>
<a name="l00006"></a>00006 <span class="comment"> */</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="comment">/*</span>
<a name="l00009"></a>00009 <span class="comment"> * repopage.c</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * Paging and compression functions for the vertical repository data.</span>
<a name="l00012"></a>00012 <span class="comment"> * Vertical data is grouped by key, normal data is grouped by solvable.</span>
<a name="l00013"></a>00013 <span class="comment"> * This makes searching for a string in vertical data fast as there&#39;s</span>
<a name="l00014"></a>00014 <span class="comment"> * no need to skip over data if keys we&#39;re not interested in.</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * The vertical data is split into pages, each page is compressed with a fast</span>
<a name="l00017"></a>00017 <span class="comment"> * compression algorithm. These pages are read in on demand, not recently used</span>
<a name="l00018"></a>00018 <span class="comment"> * pages automatically get dropped.</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a><a class="code" href="repopage_8c.html#a78c99ffd76a7bb3c8c74db76207e9ab4">00021</a> <span class="preprocessor">#define _XOPEN_SOURCE 500</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="repo_8h.html">repo.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="repopage_8h.html">repopage.h</a>&quot;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00037"></a><a class="code" href="repopage_8c.html#ad51ded0bbd705f02f73fc60c0b721ced">00037</a> <span class="preprocessor">#define BLOCK_SIZE (65536*1)</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#if BLOCK_SIZE &lt;= 65536</span>
<a name="l00039"></a><a class="code" href="repopage_8c.html#ae90bad5015aa1c286dc31cd37d1244c5">00039</a> <span class="preprocessor"></span><span class="keyword">typedef</span> __uint16_t Ref;
<a name="l00040"></a>00040 <span class="preprocessor">#else</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="keyword">typedef</span> __uint32_t Ref;
<a name="l00042"></a>00042 <span class="preprocessor">#endif</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="comment">/*</span>
<a name="l00045"></a>00045 <span class="comment">   The format is tailored for fast decompression (i.e. only byte based),</span>
<a name="l00046"></a>00046 <span class="comment">   and skewed to ASCII content (highest bit often not set):</span>
<a name="l00047"></a>00047 <span class="comment">   </span>
<a name="l00048"></a>00048 <span class="comment">   a 0LLLLLLL</span>
<a name="l00049"></a>00049 <span class="comment">        - self-describing ASCII character hex L</span>
<a name="l00050"></a>00050 <span class="comment">   b 100lllll &lt;l+1 bytes&gt;</span>
<a name="l00051"></a>00051 <span class="comment">        - literal run of length l+1</span>
<a name="l00052"></a>00052 <span class="comment">   c 101oolll &lt;8o&gt;</span>
<a name="l00053"></a>00053 <span class="comment">        - back ref of length l+2, at offset -(o+1) (o &lt; 1 &lt;&lt; 10)</span>
<a name="l00054"></a>00054 <span class="comment">   d 110lllll &lt;8o&gt;</span>
<a name="l00055"></a>00055 <span class="comment">        - back ref of length l+2+8, at offset -(o+1) (o &lt; 1 &lt;&lt; 8)</span>
<a name="l00056"></a>00056 <span class="comment">   e 1110llll &lt;8o&gt; &lt;8o&gt;</span>
<a name="l00057"></a>00057 <span class="comment">        - back ref of length l+3, at offset -(o+1) (o &lt; 1 &lt;&lt; 16)</span>
<a name="l00058"></a>00058 <span class="comment">  f1 1111llll &lt;8l&gt; &lt;8o&gt; &lt;8o&gt;</span>
<a name="l00059"></a>00059 <span class="comment">        - back ref, length l+19 (l &lt; 1&lt;&lt;12), offset -(o+1) (o &lt; 1&lt;&lt;16)</span>
<a name="l00060"></a>00060 <span class="comment">  f2 11110lll &lt;8l&gt; &lt;8o&gt; &lt;8o&gt;</span>
<a name="l00061"></a>00061 <span class="comment">        - back ref, length l+19 (l &lt; 1&lt;&lt;11), offset -(o+1) (o &lt; 1&lt;&lt;16)</span>
<a name="l00062"></a>00062 <span class="comment">   g 11111lll &lt;8l&gt; &lt;8o&gt; &lt;8o&gt; &lt;8o&gt;</span>
<a name="l00063"></a>00063 <span class="comment">        - back ref, length l+5 (l &lt; 1&lt;&lt;11), offset -(o+1) (o &lt; 1&lt;&lt;24)</span>
<a name="l00064"></a>00064 <span class="comment"></span>
<a name="l00065"></a>00065 <span class="comment">   Generally for a literal of length L we need L+1 bytes, hence it is</span>
<a name="l00066"></a>00066 <span class="comment">   better to encode also very short backrefs (2 chars) as backrefs if</span>
<a name="l00067"></a>00067 <span class="comment">   their offset is small, as that only needs two bytes.  Except if we</span>
<a name="l00068"></a>00068 <span class="comment">   already have a literal run, in that case it&#39;s better to append there,</span>
<a name="l00069"></a>00069 <span class="comment">   instead of breaking it for a backref.  So given a potential backref</span>
<a name="l00070"></a>00070 <span class="comment">   at offset O, length L the strategy is as follows:</span>
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">   L &lt; 2 : encode as 1-literal</span>
<a name="l00073"></a>00073 <span class="comment">   L == 2, O &gt; 1024 : encode as 1-literal</span>
<a name="l00074"></a>00074 <span class="comment">   L == 2, have already literals: encode as 1-literal</span>
<a name="l00075"></a>00075 <span class="comment">   O = O - 1</span>
<a name="l00076"></a>00076 <span class="comment">   L &gt;= 2, L &lt;= 9, O &lt; 1024                            : encode as c</span>
<a name="l00077"></a>00077 <span class="comment">   L &gt;= 10, L &lt;= 41, O &lt; 256                           : encode as d</span>
<a name="l00078"></a>00078 <span class="comment">   else we have either O &gt;= 1024, or L &gt;= 42:</span>
<a name="l00079"></a>00079 <span class="comment">   L &lt; 3 : encode as 1-literal</span>
<a name="l00080"></a>00080 <span class="comment">   L &gt;= 3, L &lt;= 18, O &lt; 65536                          : encode as e</span>
<a name="l00081"></a>00081 <span class="comment">   L &gt;= 19, L &lt;= 4095+18, O &lt; 65536                    : encode as f</span>
<a name="l00082"></a>00082 <span class="comment">   else we have either L &gt;= 4096+18 or O &gt;= 65536.</span>
<a name="l00083"></a>00083 <span class="comment">   O &gt;= 65536: encode as 1-literal, too bad</span>
<a name="l00084"></a>00084 <span class="comment">     (with the current block size this can&#39;t happen)</span>
<a name="l00085"></a>00085 <span class="comment">   L &gt;= 4096+18, so reduce to 4095+18                  : encode as f</span>
<a name="l00086"></a>00086 <span class="comment">*/</span>
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00090"></a><a class="code" href="repopage_8c.html#aea807f8749a003e856e06b3836109af6">00090</a> <a class="code" href="repodata_8c.html#a02d45a8e61f3d30e42080e65d267dfcc">compress_buf</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> in_len,
<a name="l00091"></a>00091               <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> out_len)
<a name="l00092"></a>00092 {
<a name="l00093"></a>00093   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oo = 0;          <span class="comment">//out-offset</span>
<a name="l00094"></a>00094   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> io = 0;          <span class="comment">//in-offset</span>
<a name="l00095"></a>00095 <span class="preprocessor">#define HS (65536)</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>  <a class="code" href="repopage_8c.html#ae90bad5015aa1c286dc31cd37d1244c5">Ref</a> htab[HS];
<a name="l00097"></a>00097   <a class="code" href="repopage_8c.html#ae90bad5015aa1c286dc31cd37d1244c5">Ref</a> hnext[BLOCK_SIZE];
<a name="l00098"></a>00098   memset(htab, -1, <span class="keyword">sizeof</span> (htab));
<a name="l00099"></a>00099   memset(hnext, -1, <span class="keyword">sizeof</span> (hnext));
<a name="l00100"></a>00100   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> litofs = 0;
<a name="l00101"></a>00101   <span class="keywordflow">while</span> (io + 2 &lt; in_len)
<a name="l00102"></a>00102     {
<a name="l00103"></a>00103       <span class="comment">/* Search for a match of the string starting at IN, we have at</span>
<a name="l00104"></a>00104 <span class="comment">         least three characters.  */</span>
<a name="l00105"></a>00105       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hval = in[io] | in[io + 1] &lt;&lt; 8 | in[io + 2] &lt;&lt; 16;
<a name="l00106"></a>00106       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordflow">try</span>, mlen, mofs, tries;
<a name="l00107"></a>00107       hval = (hval ^ (hval &lt;&lt; 5) ^ (hval &gt;&gt; 5)) - hval * 5;
<a name="l00108"></a>00108       hval = hval &amp; (<a class="code" href="repopage_8c.html#a75ada8dfcff5e2984c05762948c72792">HS</a> - 1);
<a name="l00109"></a>00109       <span class="keywordflow">try</span> = htab[hval];
<a name="l00110"></a>00110       hnext[io] = htab[hval];
<a name="l00111"></a>00111       htab[hval] = io;
<a name="l00112"></a>00112       mlen = 0;
<a name="l00113"></a>00113       mofs = 0;
<a name="l00114"></a>00114 
<a name="l00115"></a>00115       <span class="keywordflow">for</span> (tries = 0; <span class="keywordflow">try</span> != -1 &amp;&amp; tries &lt; 12; tries++)
<a name="l00116"></a>00116         {
<a name="l00117"></a>00117           <span class="keywordflow">if</span> (<span class="keywordflow">try</span> &lt; io
<a name="l00118"></a>00118               &amp;&amp; in[<span class="keywordflow">try</span>] == in[io] &amp;&amp; in[<span class="keywordflow">try</span> + 1] == in[io + 1])
<a name="l00119"></a>00119             {
<a name="l00120"></a>00120               mlen = 2;
<a name="l00121"></a>00121               mofs = (io - <span class="keywordflow">try</span>) - 1;
<a name="l00122"></a>00122               <span class="keywordflow">break</span>;
<a name="l00123"></a>00123             }
<a name="l00124"></a>00124           <span class="keywordflow">try</span> = hnext[<span class="keywordflow">try</span>];
<a name="l00125"></a>00125         }
<a name="l00126"></a>00126       <span class="keywordflow">for</span> (; <span class="keywordflow">try</span> != -1 &amp;&amp; tries &lt; 12; tries++)
<a name="l00127"></a>00127         {
<a name="l00128"></a>00128           <span class="comment">//assert(mlen &gt;= 2);</span>
<a name="l00129"></a>00129           <span class="comment">//assert(io + mlen &lt; in_len);</span>
<a name="l00130"></a>00130           <span class="comment">/* Try a match starting from [io] with the strings at [try].</span>
<a name="l00131"></a>00131 <span class="comment">             That&#39;s only sensible if TRY actually is before IO (can happen</span>
<a name="l00132"></a>00132 <span class="comment">             with uninit hash table).  If we have a previous match already</span>
<a name="l00133"></a>00133 <span class="comment">             we&#39;re only going to take the new one if it&#39;s longer, hence</span>
<a name="l00134"></a>00134 <span class="comment">             check the potentially last character.  */</span>
<a name="l00135"></a>00135           <span class="keywordflow">if</span> (<span class="keywordflow">try</span> &lt; io &amp;&amp; in[<span class="keywordflow">try</span> + mlen] == in[io + mlen])
<a name="l00136"></a>00136             {
<a name="l00137"></a>00137               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> this_len, this_ofs;
<a name="l00138"></a>00138               <span class="keywordflow">if</span> (memcmp(in + <span class="keywordflow">try</span>, in + io, mlen))
<a name="l00139"></a>00139                 <span class="keywordflow">goto</span> no_match;
<a name="l00140"></a>00140               this_len = mlen + 1;
<a name="l00141"></a>00141               <span class="comment">/* Now try extending the match by more characters.  */</span>
<a name="l00142"></a>00142               <span class="keywordflow">for</span> (;
<a name="l00143"></a>00143                    io + this_len &lt; in_len
<a name="l00144"></a>00144                    &amp;&amp; in[<span class="keywordflow">try</span> + this_len] == in[io + this_len]; this_len++)
<a name="l00145"></a>00145                 ;
<a name="l00146"></a>00146 <span class="preprocessor">#if 0</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span>              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> testi;
<a name="l00148"></a>00148               <span class="keywordflow">for</span> (testi = 0; testi &lt; this_len; testi++)
<a name="l00149"></a>00149                 assert(in[<span class="keywordflow">try</span> + testi] == in[io + testi]);
<a name="l00150"></a>00150 <span class="preprocessor">#endif</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span>              this_ofs = (io - <span class="keywordflow">try</span>) - 1;
<a name="l00152"></a>00152               <span class="comment">/*if (this_ofs &gt; 65535)</span>
<a name="l00153"></a>00153 <span class="comment">                 goto no_match; */</span>
<a name="l00154"></a>00154 <span class="preprocessor">#if 0</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span>              assert(this_len &gt;= 2);
<a name="l00156"></a>00156               assert(this_len &gt;= mlen);
<a name="l00157"></a>00157               assert(this_len &gt; mlen || (this_len == mlen &amp;&amp; this_ofs &gt; mofs));
<a name="l00158"></a>00158 <span class="preprocessor">#endif</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>              mlen = this_len, mofs = this_ofs;
<a name="l00160"></a>00160               <span class="comment">/* If our match extends up to the end of input, no next</span>
<a name="l00161"></a>00161 <span class="comment">                 match can become better.  This is not just an</span>
<a name="l00162"></a>00162 <span class="comment">                 optimization, it establishes a loop invariant</span>
<a name="l00163"></a>00163 <span class="comment">                 (io + mlen &lt; in_len).  */</span>
<a name="l00164"></a>00164               <span class="keywordflow">if</span> (io + mlen &gt;= in_len)
<a name="l00165"></a>00165                 <span class="keywordflow">goto</span> match_done;
<a name="l00166"></a>00166             }
<a name="l00167"></a>00167         no_match:
<a name="l00168"></a>00168           <span class="keywordflow">try</span> = hnext[<span class="keywordflow">try</span>];
<a name="l00169"></a>00169           <span class="comment">/*if (io - try - 1 &gt;= 65536)</span>
<a name="l00170"></a>00170 <span class="comment">            break;*/</span>
<a name="l00171"></a>00171         }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 match_done:
<a name="l00174"></a>00174       <span class="keywordflow">if</span> (mlen)
<a name="l00175"></a>00175         {
<a name="l00176"></a>00176           <span class="comment">/*fprintf(stderr, &quot;%d %d\n&quot;, mlen, mofs);*/</span>
<a name="l00177"></a>00177           <span class="keywordflow">if</span> (mlen == 2 &amp;&amp; (litofs || mofs &gt;= 1024))
<a name="l00178"></a>00178             mlen = 0;
<a name="l00179"></a>00179           <span class="comment">/*else if (mofs &gt;= 65536)</span>
<a name="l00180"></a>00180 <span class="comment">            mlen = 0;*/</span>
<a name="l00181"></a>00181           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mofs &gt;= 65536)
<a name="l00182"></a>00182             {
<a name="l00183"></a>00183               <span class="keywordflow">if</span> (mlen &gt;= 2048 + 5)
<a name="l00184"></a>00184                 mlen = 2047 + 5;
<a name="l00185"></a>00185               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mlen &lt; 5)
<a name="l00186"></a>00186                 mlen = 0;
<a name="l00187"></a>00187             }
<a name="l00188"></a>00188           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mlen &lt; 3)
<a name="l00189"></a>00189             mlen = 0;
<a name="l00190"></a>00190           <span class="comment">/*else if (mlen &gt;= 4096 + 19)</span>
<a name="l00191"></a>00191 <span class="comment">            mlen = 4095 + 19;*/</span>
<a name="l00192"></a>00192           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mlen &gt;= 2048 + 19)
<a name="l00193"></a>00193             mlen = 2047 + 19;
<a name="l00194"></a>00194           <span class="comment">/* Skip this match if the next character would deliver a better one,</span>
<a name="l00195"></a>00195 <span class="comment">             but only do this if we have the chance to really extend the</span>
<a name="l00196"></a>00196 <span class="comment">             length (i.e. our current length isn&#39;t yet the (conservative)</span>
<a name="l00197"></a>00197 <span class="comment">             maximum).  */</span>
<a name="l00198"></a>00198           <span class="keywordflow">if</span> (mlen &amp;&amp; mlen &lt; (2048 + 5) &amp;&amp; io + 3 &lt; in_len)
<a name="l00199"></a>00199             {
<a name="l00200"></a>00200               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hval =
<a name="l00201"></a>00201                 in[io + 1] | in[io + 2] &lt;&lt; 8 | in[io + 3] &lt;&lt; 16;
<a name="l00202"></a>00202               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordflow">try</span>;
<a name="l00203"></a>00203               hval = (hval ^ (hval &lt;&lt; 5) ^ (hval &gt;&gt; 5)) - hval * 5;
<a name="l00204"></a>00204               hval = hval &amp; (<a class="code" href="repopage_8c.html#a75ada8dfcff5e2984c05762948c72792">HS</a> - 1);
<a name="l00205"></a>00205               <span class="keywordflow">try</span> = htab[hval];
<a name="l00206"></a>00206               <span class="keywordflow">if</span> (<span class="keywordflow">try</span> &lt; io + 1
<a name="l00207"></a>00207                   &amp;&amp; in[<span class="keywordflow">try</span>] == in[io + 1] &amp;&amp; in[<span class="keywordflow">try</span> + 1] == in[io + 2])
<a name="l00208"></a>00208                 {
<a name="l00209"></a>00209                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> this_len;
<a name="l00210"></a>00210                   this_len = 2;
<a name="l00211"></a>00211                   <span class="keywordflow">for</span> (;
<a name="l00212"></a>00212                        io + 1 + this_len &lt; in_len
<a name="l00213"></a>00213                        &amp;&amp; in[<span class="keywordflow">try</span> + this_len] == in[io + 1 + this_len];
<a name="l00214"></a>00214                        this_len++)
<a name="l00215"></a>00215                     ;
<a name="l00216"></a>00216                   <span class="keywordflow">if</span> (this_len &gt;= mlen)
<a name="l00217"></a>00217                     mlen = 0;
<a name="l00218"></a>00218                 }
<a name="l00219"></a>00219             }
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221       <span class="keywordflow">if</span> (!mlen)
<a name="l00222"></a>00222         {
<a name="l00223"></a>00223           <span class="keywordflow">if</span> (!litofs)
<a name="l00224"></a>00224             litofs = io + 1;
<a name="l00225"></a>00225           io++;
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227       <span class="keywordflow">else</span>
<a name="l00228"></a>00228         {
<a name="l00229"></a>00229           <span class="keywordflow">if</span> (litofs)
<a name="l00230"></a>00230             {
<a name="l00231"></a>00231               litofs--;
<a name="l00232"></a>00232               <span class="keywordtype">unsigned</span> litlen = io - litofs;
<a name="l00233"></a>00233               <span class="comment">//fprintf(stderr, &quot;lit: %d\n&quot;, litlen);</span>
<a name="l00234"></a>00234               <span class="keywordflow">while</span> (litlen)
<a name="l00235"></a>00235                 {
<a name="l00236"></a>00236                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> easy_sz;
<a name="l00237"></a>00237                   <span class="comment">/* Emit everything we can as self-describers.  As soon as</span>
<a name="l00238"></a>00238 <span class="comment">                     we hit a byte we can&#39;t emit as such we&#39;re going to emit</span>
<a name="l00239"></a>00239 <span class="comment">                     a length descriptor anyway, so we can as well include</span>
<a name="l00240"></a>00240 <span class="comment">                     bytes &lt; 0x80 which might follow afterwards in that run.  */</span>
<a name="l00241"></a>00241                   <span class="keywordflow">for</span> (easy_sz = 0;
<a name="l00242"></a>00242                        easy_sz &lt; litlen &amp;&amp; in[litofs + easy_sz] &lt; 0x80;
<a name="l00243"></a>00243                        easy_sz++)
<a name="l00244"></a>00244                     ;
<a name="l00245"></a>00245                   <span class="keywordflow">if</span> (easy_sz)
<a name="l00246"></a>00246                     {
<a name="l00247"></a>00247                       <span class="keywordflow">if</span> (oo + easy_sz &gt;= out_len)
<a name="l00248"></a>00248                         <span class="keywordflow">return</span> 0;
<a name="l00249"></a>00249                       memcpy(out + oo, in + litofs, easy_sz);
<a name="l00250"></a>00250                       litofs += easy_sz;
<a name="l00251"></a>00251                       oo += easy_sz;
<a name="l00252"></a>00252                       litlen -= easy_sz;
<a name="l00253"></a>00253                       <span class="keywordflow">if</span> (!litlen)
<a name="l00254"></a>00254                         <span class="keywordflow">break</span>;
<a name="l00255"></a>00255                     }
<a name="l00256"></a>00256                   <span class="keywordflow">if</span> (litlen &lt;= 32)
<a name="l00257"></a>00257                     {
<a name="l00258"></a>00258                       <span class="keywordflow">if</span> (oo + 1 + litlen &gt;= out_len)
<a name="l00259"></a>00259                         <span class="keywordflow">return</span> 0;
<a name="l00260"></a>00260                       out[oo++] = 0x80 | (litlen - 1);
<a name="l00261"></a>00261                       <span class="keywordflow">while</span> (litlen--)
<a name="l00262"></a>00262                         out[oo++] = in[litofs++];
<a name="l00263"></a>00263                       <span class="keywordflow">break</span>;
<a name="l00264"></a>00264                     }
<a name="l00265"></a>00265                   <span class="keywordflow">else</span>
<a name="l00266"></a>00266                     {
<a name="l00267"></a>00267                       <span class="comment">/* Literal length &gt; 32, so chunk it.  */</span>
<a name="l00268"></a>00268                       <span class="keywordflow">if</span> (oo + 1 + 32 &gt;= out_len)
<a name="l00269"></a>00269                         <span class="keywordflow">return</span> 0;
<a name="l00270"></a>00270                       out[oo++] = 0x80 | 31;
<a name="l00271"></a>00271                       memcpy(out + oo, in + litofs, 32);
<a name="l00272"></a>00272                       oo += 32;
<a name="l00273"></a>00273                       litofs += 32;
<a name="l00274"></a>00274                       litlen -= 32;
<a name="l00275"></a>00275                     }
<a name="l00276"></a>00276                 }
<a name="l00277"></a>00277               litofs = 0;
<a name="l00278"></a>00278             }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280           <span class="comment">//fprintf(stderr, &quot;ref: %d @ %d\n&quot;, mlen, mofs);</span>
<a name="l00281"></a>00281 
<a name="l00282"></a>00282           <span class="keywordflow">if</span> (mlen &gt;= 2 &amp;&amp; mlen &lt;= 9 &amp;&amp; mofs &lt; 1024)
<a name="l00283"></a>00283             {
<a name="l00284"></a>00284               <span class="keywordflow">if</span> (oo + 2 &gt;= out_len)
<a name="l00285"></a>00285                 <span class="keywordflow">return</span> 0;
<a name="l00286"></a>00286               out[oo++] = 0xa0 | ((mofs &amp; 0x300) &gt;&gt; 5) | (mlen - 2);
<a name="l00287"></a>00287               out[oo++] = mofs &amp; 0xff;
<a name="l00288"></a>00288             }
<a name="l00289"></a>00289           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mlen &gt;= 10 &amp;&amp; mlen &lt;= 41 &amp;&amp; mofs &lt; 256)
<a name="l00290"></a>00290             {
<a name="l00291"></a>00291               <span class="keywordflow">if</span> (oo + 2 &gt;= out_len)
<a name="l00292"></a>00292                 <span class="keywordflow">return</span> 0;
<a name="l00293"></a>00293               out[oo++] = 0xc0 | (mlen - 10);
<a name="l00294"></a>00294               out[oo++] = mofs;
<a name="l00295"></a>00295             }
<a name="l00296"></a>00296           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mofs &gt;= 65536)
<a name="l00297"></a>00297             {
<a name="l00298"></a>00298               assert(mlen &gt;= 5 &amp;&amp; mlen &lt; 2048 + 5);
<a name="l00299"></a>00299               <span class="keywordflow">if</span> (oo + 5 &gt;= out_len)
<a name="l00300"></a>00300                 <span class="keywordflow">return</span> 0;
<a name="l00301"></a>00301               out[oo++] = 0xf8 | ((mlen - 5) &gt;&gt; 8);
<a name="l00302"></a>00302               out[oo++] = (mlen - 5) &amp; 0xff;
<a name="l00303"></a>00303               out[oo++] = mofs &amp; 0xff;
<a name="l00304"></a>00304               out[oo++] = (mofs &gt;&gt; 8) &amp; 0xff;
<a name="l00305"></a>00305               out[oo++] = mofs &gt;&gt; 16;
<a name="l00306"></a>00306             }
<a name="l00307"></a>00307           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mlen &gt;= 3 &amp;&amp; mlen &lt;= 18)
<a name="l00308"></a>00308             {
<a name="l00309"></a>00309               assert(mofs &lt; 65536);
<a name="l00310"></a>00310               <span class="keywordflow">if</span> (oo + 3 &gt;= out_len)
<a name="l00311"></a>00311                 <span class="keywordflow">return</span> 0;
<a name="l00312"></a>00312               out[oo++] = 0xe0 | (mlen - 3);
<a name="l00313"></a>00313               out[oo++] = mofs &amp; 0xff;
<a name="l00314"></a>00314               out[oo++] = mofs &gt;&gt; 8;
<a name="l00315"></a>00315             }
<a name="l00316"></a>00316           <span class="keywordflow">else</span>
<a name="l00317"></a>00317             {
<a name="l00318"></a>00318               assert(mlen &gt;= 19 &amp;&amp; mlen &lt;= 4095 + 19 &amp;&amp; mofs &lt; 65536);
<a name="l00319"></a>00319               <span class="keywordflow">if</span> (oo + 4 &gt;= out_len)
<a name="l00320"></a>00320                 <span class="keywordflow">return</span> 0;
<a name="l00321"></a>00321               out[oo++] = 0xf0 | ((mlen - 19) &gt;&gt; 8);
<a name="l00322"></a>00322               out[oo++] = (mlen - 19) &amp; 0xff;
<a name="l00323"></a>00323               out[oo++] = mofs &amp; 0xff;
<a name="l00324"></a>00324               out[oo++] = mofs &gt;&gt; 8;
<a name="l00325"></a>00325             }
<a name="l00326"></a>00326           <span class="comment">/* Insert the hashes for the compressed run [io..io+mlen-1].</span>
<a name="l00327"></a>00327 <span class="comment">             For [io] we have it already done at the start of the loop.</span>
<a name="l00328"></a>00328 <span class="comment">             So it&#39;s from [io+1..io+mlen-1], and we need three chars per</span>
<a name="l00329"></a>00329 <span class="comment">             hash, so the accessed characters will be [io+1..io+mlen-1+2],</span>
<a name="l00330"></a>00330 <span class="comment">             ergo io+mlen+1 &lt; in_len.  */</span>
<a name="l00331"></a>00331           mlen--;
<a name="l00332"></a>00332           io++;
<a name="l00333"></a>00333           <span class="keywordflow">while</span> (mlen--)
<a name="l00334"></a>00334             {
<a name="l00335"></a>00335               <span class="keywordflow">if</span> (io + 2 &lt; in_len)
<a name="l00336"></a>00336                 {
<a name="l00337"></a>00337                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hval =
<a name="l00338"></a>00338                     in[io] | in[io + 1] &lt;&lt; 8 | in[io + 2] &lt;&lt; 16;
<a name="l00339"></a>00339                   hval = (hval ^ (hval &lt;&lt; 5) ^ (hval &gt;&gt; 5)) - hval * 5;
<a name="l00340"></a>00340                   hval = hval &amp; (<a class="code" href="repopage_8c.html#a75ada8dfcff5e2984c05762948c72792">HS</a> - 1);
<a name="l00341"></a>00341                   hnext[io] = htab[hval];
<a name="l00342"></a>00342                   htab[hval] = io;
<a name="l00343"></a>00343                 }
<a name="l00344"></a>00344               io++;
<a name="l00345"></a>00345             };
<a name="l00346"></a>00346         }
<a name="l00347"></a>00347     }
<a name="l00348"></a>00348   <span class="comment">/* We might have some characters left.  */</span>
<a name="l00349"></a>00349   <span class="keywordflow">if</span> (io &lt; in_len &amp;&amp; !litofs)
<a name="l00350"></a>00350     litofs = io + 1;
<a name="l00351"></a>00351   io = in_len;
<a name="l00352"></a>00352   <span class="keywordflow">if</span> (litofs)
<a name="l00353"></a>00353     {
<a name="l00354"></a>00354       litofs--;
<a name="l00355"></a>00355       <span class="keywordtype">unsigned</span> litlen = io - litofs;
<a name="l00356"></a>00356       <span class="comment">//fprintf(stderr, &quot;lit: %d\n&quot;, litlen);</span>
<a name="l00357"></a>00357       <span class="keywordflow">while</span> (litlen)
<a name="l00358"></a>00358         {
<a name="l00359"></a>00359           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> easy_sz;
<a name="l00360"></a>00360           <span class="comment">/* Emit everything we can as self-describers.  As soon as we hit a</span>
<a name="l00361"></a>00361 <span class="comment">             byte we can&#39;t emit as such we&#39;re going to emit a length</span>
<a name="l00362"></a>00362 <span class="comment">             descriptor anyway, so we can as well include bytes &lt; 0x80 which</span>
<a name="l00363"></a>00363 <span class="comment">             might follow afterwards in that run.  */</span>
<a name="l00364"></a>00364           <span class="keywordflow">for</span> (easy_sz = 0; easy_sz &lt; litlen &amp;&amp; in[litofs + easy_sz] &lt; 0x80;
<a name="l00365"></a>00365                easy_sz++)
<a name="l00366"></a>00366             ;
<a name="l00367"></a>00367           <span class="keywordflow">if</span> (easy_sz)
<a name="l00368"></a>00368             {
<a name="l00369"></a>00369               <span class="keywordflow">if</span> (oo + easy_sz &gt;= out_len)
<a name="l00370"></a>00370                 <span class="keywordflow">return</span> 0;
<a name="l00371"></a>00371               memcpy(out + oo, in + litofs, easy_sz);
<a name="l00372"></a>00372               litofs += easy_sz;
<a name="l00373"></a>00373               oo += easy_sz;
<a name="l00374"></a>00374               litlen -= easy_sz;
<a name="l00375"></a>00375               <span class="keywordflow">if</span> (!litlen)
<a name="l00376"></a>00376                 <span class="keywordflow">break</span>;
<a name="l00377"></a>00377             }
<a name="l00378"></a>00378           <span class="keywordflow">if</span> (litlen &lt;= 32)
<a name="l00379"></a>00379             {
<a name="l00380"></a>00380               <span class="keywordflow">if</span> (oo + 1 + litlen &gt;= out_len)
<a name="l00381"></a>00381                 <span class="keywordflow">return</span> 0;
<a name="l00382"></a>00382               out[oo++] = 0x80 | (litlen - 1);
<a name="l00383"></a>00383               <span class="keywordflow">while</span> (litlen--)
<a name="l00384"></a>00384                 out[oo++] = in[litofs++];
<a name="l00385"></a>00385               <span class="keywordflow">break</span>;
<a name="l00386"></a>00386             }
<a name="l00387"></a>00387           <span class="keywordflow">else</span>
<a name="l00388"></a>00388             {
<a name="l00389"></a>00389               <span class="comment">/* Literal length &gt; 32, so chunk it.  */</span>
<a name="l00390"></a>00390               <span class="keywordflow">if</span> (oo + 1 + 32 &gt;= out_len)
<a name="l00391"></a>00391                 <span class="keywordflow">return</span> 0;
<a name="l00392"></a>00392               out[oo++] = 0x80 | 31;
<a name="l00393"></a>00393               memcpy(out + oo, in + litofs, 32);
<a name="l00394"></a>00394               oo += 32;
<a name="l00395"></a>00395               litofs += 32;
<a name="l00396"></a>00396               litlen -= 32;
<a name="l00397"></a>00397             }
<a name="l00398"></a>00398         }
<a name="l00399"></a>00399       litofs = 0;
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401   <span class="keywordflow">return</span> oo;
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00405"></a><a class="code" href="repopage_8c.html#a1c397eba97869819e3b38f869f1f2247">00405</a> <a class="code" href="repodata_8c.html#acaff5763966269b0341bf6a38fbb401f">unchecked_decompress_buf</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> in_len,
<a name="l00406"></a>00406                           <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out,
<a name="l00407"></a>00407                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> out_len <a class="code" href="pool_8h.html#a9d373a9b65ff25b2db84c07394e1c212">__attribute__</a>((unused)))
<a name="l00408"></a>00408 {
<a name="l00409"></a>00409   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *orig_out = out;
<a name="l00410"></a>00410   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in_end = in + in_len;
<a name="l00411"></a>00411   <span class="keywordflow">while</span> (in &lt; in_end)
<a name="l00412"></a>00412     {
<a name="l00413"></a>00413       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> first = *in++;
<a name="l00414"></a>00414       <span class="keywordtype">int</span> o;
<a name="l00415"></a>00415       <span class="keywordflow">switch</span> (first &gt;&gt; 4)
<a name="l00416"></a>00416         {
<a name="l00417"></a>00417         <span class="keywordflow">default</span>:
<a name="l00418"></a>00418           <span class="comment">/* This default case can&#39;t happen, but GCCs VRP is not strong</span>
<a name="l00419"></a>00419 <span class="comment">             enough to see this, so make this explicitely not fall to</span>
<a name="l00420"></a>00420 <span class="comment">             the end of the switch, so that we don&#39;t have to initialize</span>
<a name="l00421"></a>00421 <span class="comment">             o above.  */</span>
<a name="l00422"></a>00422           <span class="keywordflow">continue</span>;
<a name="l00423"></a>00423         <span class="keywordflow">case</span> 0: <span class="keywordflow">case</span> 1:
<a name="l00424"></a>00424         <span class="keywordflow">case</span> 2: <span class="keywordflow">case</span> 3:
<a name="l00425"></a>00425         <span class="keywordflow">case</span> 4: <span class="keywordflow">case</span> 5:
<a name="l00426"></a>00426         <span class="keywordflow">case</span> 6: <span class="keywordflow">case</span> 7:
<a name="l00427"></a>00427           <span class="comment">//a 0LLLLLLL</span>
<a name="l00428"></a>00428           <span class="comment">//fprintf (stderr, &quot;lit: 1\n&quot;);</span>
<a name="l00429"></a>00429           *out++ = first;
<a name="l00430"></a>00430           <span class="keywordflow">continue</span>;
<a name="l00431"></a>00431         <span class="keywordflow">case</span> 8: <span class="keywordflow">case</span> 9:
<a name="l00432"></a>00432           <span class="comment">//b 100lllll &lt;l+1 bytes&gt;</span>
<a name="l00433"></a>00433           {
<a name="l00434"></a>00434             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l = first &amp; 31;
<a name="l00435"></a>00435             <span class="comment">//fprintf (stderr, &quot;lit: %d\n&quot;, l);</span>
<a name="l00436"></a>00436             <span class="keywordflow">do</span>
<a name="l00437"></a>00437               *out++ = *in++;
<a name="l00438"></a>00438             <span class="keywordflow">while</span> (l--);
<a name="l00439"></a>00439             <span class="keywordflow">continue</span>;
<a name="l00440"></a>00440           }
<a name="l00441"></a>00441         <span class="keywordflow">case</span> 10: <span class="keywordflow">case</span> 11:
<a name="l00442"></a>00442           <span class="comment">//c 101oolll &lt;8o&gt;</span>
<a name="l00443"></a>00443           {
<a name="l00444"></a>00444             o = first &amp; (3 &lt;&lt; 3);
<a name="l00445"></a>00445             o = (o &lt;&lt; 5) | *in++;
<a name="l00446"></a>00446             first = (first &amp; 7) + 2;
<a name="l00447"></a>00447             <span class="keywordflow">break</span>;
<a name="l00448"></a>00448           }
<a name="l00449"></a>00449         <span class="keywordflow">case</span> 12: <span class="keywordflow">case</span> 13:
<a name="l00450"></a>00450           <span class="comment">//d 110lllll &lt;8o&gt;</span>
<a name="l00451"></a>00451           {
<a name="l00452"></a>00452             o = *in++;
<a name="l00453"></a>00453             first = (first &amp; 31) + 10;
<a name="l00454"></a>00454             <span class="keywordflow">break</span>;
<a name="l00455"></a>00455           }
<a name="l00456"></a>00456         <span class="keywordflow">case</span> 14:
<a name="l00457"></a>00457           <span class="comment">// e 1110llll &lt;8o&gt; &lt;8o&gt;</span>
<a name="l00458"></a>00458           {
<a name="l00459"></a>00459             o = in[0] | (in[1] &lt;&lt; 8);
<a name="l00460"></a>00460             in += 2;
<a name="l00461"></a>00461             first = first &amp; 31;
<a name="l00462"></a>00462             first += 3;
<a name="l00463"></a>00463             <span class="keywordflow">break</span>;
<a name="l00464"></a>00464           }
<a name="l00465"></a>00465         <span class="keywordflow">case</span> 15:
<a name="l00466"></a>00466           <span class="comment">//f1 1111llll &lt;8o&gt; &lt;8o&gt; &lt;8l&gt;</span>
<a name="l00467"></a>00467           <span class="comment">//f2 11110lll &lt;8o&gt; &lt;8o&gt; &lt;8l&gt;</span>
<a name="l00468"></a>00468           <span class="comment">// g 11111lll &lt;8o&gt; &lt;8o&gt; &lt;8o&gt; &lt;8l&gt;</span>
<a name="l00469"></a>00469           {
<a name="l00470"></a>00470             first = first &amp; 15;
<a name="l00471"></a>00471             <span class="keywordflow">if</span> (first &gt;= 8)
<a name="l00472"></a>00472               {
<a name="l00473"></a>00473                 first = (((first - 8) &lt;&lt; 8) | in[0]) + 5;
<a name="l00474"></a>00474                 o = in[1] | (in[2] &lt;&lt; 8) | (in[3] &lt;&lt; 16);
<a name="l00475"></a>00475                 in += 4;
<a name="l00476"></a>00476               }
<a name="l00477"></a>00477             <span class="keywordflow">else</span>
<a name="l00478"></a>00478               {
<a name="l00479"></a>00479                 first = ((first &lt;&lt; 8) | in[0]) + 19;
<a name="l00480"></a>00480                 o = in[1] | (in[2] &lt;&lt; 8);
<a name="l00481"></a>00481                 in += 3;
<a name="l00482"></a>00482               }
<a name="l00483"></a>00483             <span class="keywordflow">break</span>;
<a name="l00484"></a>00484           }
<a name="l00485"></a>00485         }
<a name="l00486"></a>00486       <span class="comment">//fprintf(stderr, &quot;ref: %d @ %d\n&quot;, first, o);</span>
<a name="l00487"></a>00487       o++;
<a name="l00488"></a>00488       o = -o;
<a name="l00489"></a>00489 <span class="preprocessor">#if 0</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span>      <span class="comment">/* We know that first will not be zero, and this loop structure is</span>
<a name="l00491"></a>00491 <span class="comment">         better optimizable.  */</span>
<a name="l00492"></a>00492       <span class="keywordflow">do</span>
<a name="l00493"></a>00493         {
<a name="l00494"></a>00494           *out = *(out - o);
<a name="l00495"></a>00495           out++;
<a name="l00496"></a>00496         }
<a name="l00497"></a>00497       <span class="keywordflow">while</span> (--first);
<a name="l00498"></a>00498 <span class="preprocessor">#else</span>
<a name="l00499"></a>00499 <span class="preprocessor"></span>      <span class="keywordflow">switch</span> (first)
<a name="l00500"></a>00500         {
<a name="l00501"></a>00501           <span class="keywordflow">case</span> 18: *out = *(out + o); out++;
<a name="l00502"></a>00502           <span class="keywordflow">case</span> 17: *out = *(out + o); out++;
<a name="l00503"></a>00503           <span class="keywordflow">case</span> 16: *out = *(out + o); out++;
<a name="l00504"></a>00504           <span class="keywordflow">case</span> 15: *out = *(out + o); out++;
<a name="l00505"></a>00505           <span class="keywordflow">case</span> 14: *out = *(out + o); out++;
<a name="l00506"></a>00506           <span class="keywordflow">case</span> 13: *out = *(out + o); out++;
<a name="l00507"></a>00507           <span class="keywordflow">case</span> 12: *out = *(out + o); out++;
<a name="l00508"></a>00508           <span class="keywordflow">case</span> 11: *out = *(out + o); out++;
<a name="l00509"></a>00509           <span class="keywordflow">case</span> 10: *out = *(out + o); out++;
<a name="l00510"></a>00510           <span class="keywordflow">case</span>  9: *out = *(out + o); out++;
<a name="l00511"></a>00511           <span class="keywordflow">case</span>  8: *out = *(out + o); out++;
<a name="l00512"></a>00512           <span class="keywordflow">case</span>  7: *out = *(out + o); out++;
<a name="l00513"></a>00513           <span class="keywordflow">case</span>  6: *out = *(out + o); out++;
<a name="l00514"></a>00514           <span class="keywordflow">case</span>  5: *out = *(out + o); out++;
<a name="l00515"></a>00515           <span class="keywordflow">case</span>  4: *out = *(out + o); out++;
<a name="l00516"></a>00516           <span class="keywordflow">case</span>  3: *out = *(out + o); out++;
<a name="l00517"></a>00517           <span class="keywordflow">case</span>  2: *out = *(out + o); out++;
<a name="l00518"></a>00518           <span class="keywordflow">case</span>  1: *out = *(out + o); out++;
<a name="l00519"></a>00519           <span class="keywordflow">case</span>  0: <span class="keywordflow">break</span>;
<a name="l00520"></a>00520           <span class="keywordflow">default</span>:
<a name="l00521"></a>00521             <span class="comment">/* Duff duff :-) */</span>
<a name="l00522"></a>00522             <span class="keywordflow">switch</span> (first &amp; 15)
<a name="l00523"></a>00523               {
<a name="l00524"></a>00524                 <span class="keywordflow">do</span>
<a name="l00525"></a>00525                   {
<a name="l00526"></a>00526                     <span class="keywordflow">case</span>  0: *out = *(out + o); out++;
<a name="l00527"></a>00527                     <span class="keywordflow">case</span> 15: *out = *(out + o); out++;
<a name="l00528"></a>00528                     <span class="keywordflow">case</span> 14: *out = *(out + o); out++;
<a name="l00529"></a>00529                     <span class="keywordflow">case</span> 13: *out = *(out + o); out++;
<a name="l00530"></a>00530                     <span class="keywordflow">case</span> 12: *out = *(out + o); out++;
<a name="l00531"></a>00531                     <span class="keywordflow">case</span> 11: *out = *(out + o); out++;
<a name="l00532"></a>00532                     <span class="keywordflow">case</span> 10: *out = *(out + o); out++;
<a name="l00533"></a>00533                     <span class="keywordflow">case</span>  9: *out = *(out + o); out++;
<a name="l00534"></a>00534                     <span class="keywordflow">case</span>  8: *out = *(out + o); out++;
<a name="l00535"></a>00535                     <span class="keywordflow">case</span>  7: *out = *(out + o); out++;
<a name="l00536"></a>00536                     <span class="keywordflow">case</span>  6: *out = *(out + o); out++;
<a name="l00537"></a>00537                     <span class="keywordflow">case</span>  5: *out = *(out + o); out++;
<a name="l00538"></a>00538                     <span class="keywordflow">case</span>  4: *out = *(out + o); out++;
<a name="l00539"></a>00539                     <span class="keywordflow">case</span>  3: *out = *(out + o); out++;
<a name="l00540"></a>00540                     <span class="keywordflow">case</span>  2: *out = *(out + o); out++;
<a name="l00541"></a>00541                     <span class="keywordflow">case</span>  1: *out = *(out + o); out++;
<a name="l00542"></a>00542                   }
<a name="l00543"></a>00543                 <span class="keywordflow">while</span> ((<span class="keywordtype">int</span>)(first -= 16) &gt; 0);
<a name="l00544"></a>00544               }
<a name="l00545"></a>00545             <span class="keywordflow">break</span>;
<a name="l00546"></a>00546         }
<a name="l00547"></a>00547 <span class="preprocessor">#endif</span>
<a name="l00548"></a>00548 <span class="preprocessor"></span>    }
<a name="l00549"></a>00549   <span class="keywordflow">return</span> out - orig_out;
<a name="l00550"></a>00550 }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="comment">/**********************************************************************/</span>
<a name="l00553"></a>00553 
<a name="l00554"></a><a class="code" href="repopage_8h.html#a160662da1f0a60fd42ac97180bf2a952">00554</a> <span class="keywordtype">void</span> <a class="code" href="repopage_8c.html#a160662da1f0a60fd42ac97180bf2a952">repopagestore_init</a>(<a class="code" href="struct__Repopagestore.html">Repopagestore</a> *<a class="code" href="struct__Repodata.html#a113137114fabb8455b51679000ab7b4f">store</a>)
<a name="l00555"></a>00555 {
<a name="l00556"></a>00556   memset(store, 0, <span class="keyword">sizeof</span>(*store));
<a name="l00557"></a>00557   store-&gt;<a class="code" href="struct__Repopagestore.html#a7e713db342d0fa9da389b62a39dc5532">pagefd</a> = -1;
<a name="l00558"></a>00558 }
<a name="l00559"></a>00559 
<a name="l00560"></a><a class="code" href="repopage_8h.html#a254a8fd4fc76cbb66116b1c502a3ab7e">00560</a> <span class="keywordtype">void</span> <a class="code" href="repopage_8c.html#a254a8fd4fc76cbb66116b1c502a3ab7e">repopagestore_free</a>(<a class="code" href="struct__Repopagestore.html">Repopagestore</a> *<a class="code" href="struct__Repodata.html#a113137114fabb8455b51679000ab7b4f">store</a>)
<a name="l00561"></a>00561 {
<a name="l00562"></a>00562   <a class="code" href="util_8c.html#a1f246fae10a89534cfe0583cefb44c11">sat_free</a>(store-&gt;<a class="code" href="struct__Repopagestore.html#a88e253d812362cc8fce8acac68a4eab2">blob_store</a>);
<a name="l00563"></a>00563   <a class="code" href="util_8c.html#a1f246fae10a89534cfe0583cefb44c11">sat_free</a>(store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a>);
<a name="l00564"></a>00564   <a class="code" href="util_8c.html#a1f246fae10a89534cfe0583cefb44c11">sat_free</a>(store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a>);
<a name="l00565"></a>00565   <span class="keywordflow">if</span> (store-&gt;<a class="code" href="struct__Repopagestore.html#a7e713db342d0fa9da389b62a39dc5532">pagefd</a> != -1)
<a name="l00566"></a>00566     close(store-&gt;<a class="code" href="struct__Repopagestore.html#a7e713db342d0fa9da389b62a39dc5532">pagefd</a>);
<a name="l00567"></a>00567 }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="comment">/**********************************************************************/</span>
<a name="l00571"></a>00571 
<a name="l00572"></a>00572 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *
<a name="l00573"></a><a class="code" href="repopage_8h.html#a5e983087e39e3cc9321aef3c13527460">00573</a> <a class="code" href="repopage_8c.html#a5e983087e39e3cc9321aef3c13527460">repopagestore_load_page_range</a>(<a class="code" href="struct__Repopagestore.html">Repopagestore</a> *<a class="code" href="struct__Repodata.html#a113137114fabb8455b51679000ab7b4f">store</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pstart, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pend)
<a name="l00574"></a>00574 {
<a name="l00575"></a>00575 <span class="comment">/* Make sure all pages from PSTART to PEND (inclusive) are loaded,</span>
<a name="l00576"></a>00576 <span class="comment">   and are consecutive.  Return a pointer to the mapping of PSTART.  */</span>
<a name="l00577"></a>00577   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[BLOB_PAGESIZE];
<a name="l00578"></a>00578   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580   <span class="comment">/* Quick check in case all pages are there already and consecutive.  */</span>
<a name="l00581"></a>00581   <span class="keywordflow">for</span> (i = pstart; i &lt;= pend; i++)
<a name="l00582"></a>00582     <span class="keywordflow">if</span> (store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a>[i].<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a> == -1
<a name="l00583"></a>00583         || (i &gt; pstart
<a name="l00584"></a>00584             &amp;&amp; store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a>[i].<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a>
<a name="l00585"></a>00585                != store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a>[i-1].<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a> + <a class="code" href="repopage_8h.html#afe3da5b5f40a2d44c9c5c7c75b2703d7">BLOB_PAGESIZE</a>))
<a name="l00586"></a>00586       <span class="keywordflow">break</span>;
<a name="l00587"></a>00587   <span class="keywordflow">if</span> (i &gt; pend)
<a name="l00588"></a>00588     <span class="keywordflow">return</span> store-&gt;<a class="code" href="struct__Repopagestore.html#a88e253d812362cc8fce8acac68a4eab2">blob_store</a> + store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a>[pstart].<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a>;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590   <span class="keywordflow">if</span> (store-&gt;<a class="code" href="struct__Repopagestore.html#a7e713db342d0fa9da389b62a39dc5532">pagefd</a> == -1)
<a name="l00591"></a>00591     <span class="keywordflow">return</span> 0;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   <span class="comment">/* Ensure that we can map the numbers of pages we need at all.  */</span>
<a name="l00594"></a>00594   <span class="keywordflow">if</span> (pend - pstart + 1 &gt; store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a>)
<a name="l00595"></a>00595     {
<a name="l00596"></a>00596       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldcan = store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a>;
<a name="l00597"></a>00597       store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a> = pend - pstart + 1;
<a name="l00598"></a>00598       <span class="keywordflow">if</span> (store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a> &lt; 4)
<a name="l00599"></a>00599         store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a> = 4;
<a name="l00600"></a>00600       store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a> = <a class="code" href="util_8c.html#a8f5176ce31f7fb335f55fcae625149ea">sat_realloc2</a>(store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a>, store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a>, <span class="keyword">sizeof</span>(store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a>[0]));
<a name="l00601"></a>00601       memset(store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a> + oldcan, 0, (store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a> - oldcan) * sizeof (store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a>[0]));
<a name="l00602"></a>00602       store-&gt;<a class="code" href="struct__Repopagestore.html#a88e253d812362cc8fce8acac68a4eab2">blob_store</a> = <a class="code" href="util_8c.html#a8f5176ce31f7fb335f55fcae625149ea">sat_realloc2</a>(store-&gt;<a class="code" href="struct__Repopagestore.html#a88e253d812362cc8fce8acac68a4eab2">blob_store</a>, store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a>, <a class="code" href="repopage_8h.html#afe3da5b5f40a2d44c9c5c7c75b2703d7">BLOB_PAGESIZE</a>);
<a name="l00603"></a>00603 <span class="preprocessor">#ifdef DEBUG_PAGING</span>
<a name="l00604"></a>00604 <span class="preprocessor"></span>      fprintf(stderr, <span class="stringliteral">&quot;PAGE: can map %d pages\n&quot;</span>, store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a>);
<a name="l00605"></a>00605 <span class="preprocessor">#endif</span>
<a name="l00606"></a>00606 <span class="preprocessor"></span>    }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608   <span class="comment">/* Now search for &quot;cheap&quot; space in our store.  Space is cheap if it&#39;s either</span>
<a name="l00609"></a>00609 <span class="comment">     free (very cheap) or contains pages we search for anyway.  */</span>
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <span class="comment">/* Setup cost array.  */</span>
<a name="l00612"></a>00612   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cost[store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a>];
<a name="l00613"></a>00613   <span class="keywordflow">for</span> (i = 0; i &lt; store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a>; i++)
<a name="l00614"></a>00614     {
<a name="l00615"></a>00615       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pnum = store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a>[i];
<a name="l00616"></a>00616       <span class="keywordflow">if</span> (pnum == 0)
<a name="l00617"></a>00617         cost[i] = 0;
<a name="l00618"></a>00618       <span class="keywordflow">else</span>
<a name="l00619"></a>00619         {
<a name="l00620"></a>00620           pnum--;
<a name="l00621"></a>00621           <a class="code" href="struct__Attrblobpage.html">Attrblobpage</a> *p = store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a> + pnum;
<a name="l00622"></a>00622           assert(p-&gt;<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a> != -1);
<a name="l00623"></a>00623           <span class="keywordflow">if</span> (pnum &gt;= pstart &amp;&amp; pnum &lt;= pend)
<a name="l00624"></a>00624             cost[i] = 1;
<a name="l00625"></a>00625           <span class="keywordflow">else</span>
<a name="l00626"></a>00626             cost[i] = 3;
<a name="l00627"></a>00627         }
<a name="l00628"></a>00628     }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630   <span class="comment">/* And search for cheapest space.  */</span>
<a name="l00631"></a>00631   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> best_cost = -1;
<a name="l00632"></a>00632   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> best = 0;
<a name="l00633"></a>00633   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> same_cost = 0;
<a name="l00634"></a>00634   <span class="keywordflow">for</span> (i = 0; i + pend - pstart &lt; store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a>; i++)
<a name="l00635"></a>00635     {
<a name="l00636"></a>00636       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = cost[i];
<a name="l00637"></a>00637       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j;
<a name="l00638"></a>00638       <span class="keywordflow">for</span> (j = 0; j &lt; pend - pstart + 1; j++)
<a name="l00639"></a>00639         c += cost[i+j];
<a name="l00640"></a>00640       <span class="keywordflow">if</span> (c &lt; best_cost)
<a name="l00641"></a>00641         best_cost = c, best = i;
<a name="l00642"></a>00642       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == best_cost)
<a name="l00643"></a>00643         same_cost++;
<a name="l00644"></a>00644       <span class="comment">/* A null cost won&#39;t become better.  */</span>
<a name="l00645"></a>00645       <span class="keywordflow">if</span> (c == 0)
<a name="l00646"></a>00646         <span class="keywordflow">break</span>;
<a name="l00647"></a>00647     }
<a name="l00648"></a>00648   <span class="comment">/* If all places have the same cost we would thrash on slot 0.  Avoid</span>
<a name="l00649"></a>00649 <span class="comment">     this by doing a round-robin strategy in this case.  */</span>
<a name="l00650"></a>00650   <span class="keywordflow">if</span> (same_cost == store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a> - pend + pstart - 1)
<a name="l00651"></a>00651     best = store-&gt;<a class="code" href="struct__Repopagestore.html#a7ad5fd92ef050293c5fdcd08188321d7">rr_counter</a>++ % (store-&gt;<a class="code" href="struct__Repopagestore.html#a38efe22ee77ca68dadccceb3cfa284ff">ncanmap</a> - pend + pstart);
<a name="l00652"></a>00652 
<a name="l00653"></a>00653   <span class="comment">/* So we want to map our pages from [best] to [best+pend-pstart].</span>
<a name="l00654"></a>00654 <span class="comment">     Use a very simple strategy, which doesn&#39;t make the best use of</span>
<a name="l00655"></a>00655 <span class="comment">     our resources, but works.  Throw away all pages in that range</span>
<a name="l00656"></a>00656 <span class="comment">     (even ours) then copy around ours (in case they were outside the </span>
<a name="l00657"></a>00657 <span class="comment">     range) or read them in.  */</span>
<a name="l00658"></a>00658   <span class="keywordflow">for</span> (i = best; i &lt; best + pend - pstart + 1; i++)
<a name="l00659"></a>00659     {
<a name="l00660"></a>00660       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pnum = store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a>[i];
<a name="l00661"></a>00661       <span class="keywordflow">if</span> (pnum--
<a name="l00662"></a>00662           <span class="comment">/* If this page is exactly at the right place already,</span>
<a name="l00663"></a>00663 <span class="comment">             no need to evict it.  */</span>
<a name="l00664"></a>00664           &amp;&amp; pnum != pstart + i - best)
<a name="l00665"></a>00665         {
<a name="l00666"></a>00666           <span class="comment">/* Evict this page.  */</span>
<a name="l00667"></a>00667 <span class="preprocessor">#ifdef DEBUG_PAGING</span>
<a name="l00668"></a>00668 <span class="preprocessor"></span>          fprintf(stderr, <span class="stringliteral">&quot;PAGE: evict page %d from %d\n&quot;</span>, pnum, i);
<a name="l00669"></a>00669 <span class="preprocessor">#endif</span>
<a name="l00670"></a>00670 <span class="preprocessor"></span>          cost[i] = 0;
<a name="l00671"></a>00671           store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a>[i] = 0;
<a name="l00672"></a>00672           store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a>[pnum].<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a> = -1;
<a name="l00673"></a>00673         }
<a name="l00674"></a>00674     }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676   <span class="comment">/* Everything is free now.  Read in the pages we want.  */</span>
<a name="l00677"></a>00677   <span class="keywordflow">for</span> (i = pstart; i &lt;= pend; i++)
<a name="l00678"></a>00678     {
<a name="l00679"></a>00679       <a class="code" href="struct__Attrblobpage.html">Attrblobpage</a> *p = store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a> + i;
<a name="l00680"></a>00680       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pnum = i - pstart + best;
<a name="l00681"></a>00681       <span class="keywordtype">void</span> *dest = store-&gt;<a class="code" href="struct__Repopagestore.html#a88e253d812362cc8fce8acac68a4eab2">blob_store</a> + pnum * BLOB_PAGESIZE;
<a name="l00682"></a>00682       <span class="keywordflow">if</span> (p-&gt;<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a> != -1)
<a name="l00683"></a>00683         {
<a name="l00684"></a>00684           <span class="keywordflow">if</span> (p-&gt;<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a> != pnum * BLOB_PAGESIZE)
<a name="l00685"></a>00685             {
<a name="l00686"></a>00686 <span class="preprocessor">#ifdef DEBUG_PAGING</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span>              fprintf(stderr, <span class="stringliteral">&quot;PAGECOPY: %d to %d\n&quot;</span>, i, pnum);
<a name="l00688"></a>00688 <span class="preprocessor">#endif</span>
<a name="l00689"></a>00689 <span class="preprocessor"></span>              <span class="comment">/* Still mapped somewhere else, so just copy it from there.  */</span>
<a name="l00690"></a>00690               memcpy(dest, store-&gt;<a class="code" href="struct__Repopagestore.html#a88e253d812362cc8fce8acac68a4eab2">blob_store</a> + p-&gt;<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a>, BLOB_PAGESIZE);
<a name="l00691"></a>00691               store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a>[p-&gt;<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a> / BLOB_PAGESIZE] = 0;
<a name="l00692"></a>00692             }
<a name="l00693"></a>00693         }
<a name="l00694"></a>00694       <span class="keywordflow">else</span>
<a name="l00695"></a>00695         {
<a name="l00696"></a>00696           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> in_len = p-&gt;<a class="code" href="struct__Attrblobpage.html#aa73d3dcc10ba04a20dfc690013300907">file_size</a>;
<a name="l00697"></a>00697           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> compressed = in_len &amp; 1;
<a name="l00698"></a>00698           in_len &gt;&gt;= 1;
<a name="l00699"></a>00699 <span class="preprocessor">#ifdef DEBUG_PAGING</span>
<a name="l00700"></a>00700 <span class="preprocessor"></span>          fprintf(stderr, <span class="stringliteral">&quot;PAGEIN: %d to %d&quot;</span>, i, pnum);
<a name="l00701"></a>00701 <span class="preprocessor">#endif</span>
<a name="l00702"></a>00702 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (pread(store-&gt;<a class="code" href="struct__Repopagestore.html#a7e713db342d0fa9da389b62a39dc5532">pagefd</a>, compressed ? buf : dest, in_len, p-&gt;<a class="code" href="struct__Attrblobpage.html#aa0fe8564583ab2317a87d96400f592b7">file_offset</a>) != in_len)
<a name="l00703"></a>00703             {
<a name="l00704"></a>00704               perror(<span class="stringliteral">&quot;mapping pread&quot;</span>);
<a name="l00705"></a>00705               <span class="keywordflow">return</span> 0;
<a name="l00706"></a>00706             }
<a name="l00707"></a>00707           <span class="keywordflow">if</span> (compressed)
<a name="l00708"></a>00708             {
<a name="l00709"></a>00709               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> out_len;
<a name="l00710"></a>00710               out_len = <a class="code" href="repodata_8c.html#acaff5763966269b0341bf6a38fbb401f">unchecked_decompress_buf</a>(buf, in_len,
<a name="l00711"></a>00711                                                   dest, BLOB_PAGESIZE);
<a name="l00712"></a>00712               <span class="keywordflow">if</span> (out_len != BLOB_PAGESIZE &amp;&amp; i &lt; store-&gt;num_pages - 1)
<a name="l00713"></a>00713                 {
<a name="l00714"></a>00714 <span class="preprocessor">#ifdef DEBUG_PAGING</span>
<a name="l00715"></a>00715 <span class="preprocessor"></span>                  fprintf(stderr, <span class="stringliteral">&quot;can&#39;t decompress\n&quot;</span>);
<a name="l00716"></a>00716 <span class="preprocessor">#endif</span>
<a name="l00717"></a>00717 <span class="preprocessor"></span>                  <span class="keywordflow">return</span> 0;
<a name="l00718"></a>00718                 }
<a name="l00719"></a>00719 <span class="preprocessor">#ifdef DEBUG_PAGING</span>
<a name="l00720"></a>00720 <span class="preprocessor"></span>              fprintf(stderr, <span class="stringliteral">&quot; (expand %d to %d)&quot;</span>, in_len, out_len);
<a name="l00721"></a>00721 <span class="preprocessor">#endif</span>
<a name="l00722"></a>00722 <span class="preprocessor"></span>            }
<a name="l00723"></a>00723 <span class="preprocessor">#ifdef DEBUG_PAGING</span>
<a name="l00724"></a>00724 <span class="preprocessor"></span>          fprintf(stderr, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00725"></a>00725 <span class="preprocessor">#endif</span>
<a name="l00726"></a>00726 <span class="preprocessor"></span>        }
<a name="l00727"></a>00727       p-&gt;<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a> = pnum * BLOB_PAGESIZE;
<a name="l00728"></a>00728       store-&gt;<a class="code" href="struct__Repopagestore.html#a92bb198b8f18cd33a4e7cdf557ef08ba">mapped</a>[pnum] = i + 1;
<a name="l00729"></a>00729     }
<a name="l00730"></a>00730   <span class="keywordflow">return</span> store-&gt;<a class="code" href="struct__Repopagestore.html#a88e253d812362cc8fce8acac68a4eab2">blob_store</a> + best * BLOB_PAGESIZE;
<a name="l00731"></a>00731 }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00734"></a><a class="code" href="repopage_8h.html#a1afa2b5e69bbef76c388289d73cc7177">00734</a> <a class="code" href="repopage_8c.html#a1afa2b5e69bbef76c388289d73cc7177">repopagestore_compress_page</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *page, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *cpage, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max)
<a name="l00735"></a>00735 {
<a name="l00736"></a>00736   <span class="keywordflow">return</span> <a class="code" href="repodata_8c.html#a02d45a8e61f3d30e42080e65d267dfcc">compress_buf</a>(page, len, cpage, max);
<a name="l00737"></a>00737 }
<a name="l00738"></a>00738 
<a name="l00739"></a><a class="code" href="repopage_8c.html#aa5e01797e80a9106ae533b174b40837e">00739</a> <span class="preprocessor">#define SOLV_ERROR_EOF          3</span>
<a name="l00740"></a><a class="code" href="repopage_8c.html#af0eae0ca4802e5e7e7bfb2dfee3de7ac">00740</a> <span class="preprocessor"></span><span class="preprocessor">#define SOLV_ERROR_CORRUPT      6</span>
<a name="l00741"></a>00741 <span class="preprocessor"></span>
<a name="l00742"></a>00742 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00743"></a><a class="code" href="repopage_8c.html#a9042a13324d3cbd2f5f24453913e5894">00743</a> <a class="code" href="repopage_8c.html#a9042a13324d3cbd2f5f24453913e5894">read_u32</a>(FILE *<a class="code" href="struct__Repodata.html#aa5c124481775bbfc515a3bb422e20e4a">fp</a>)
<a name="l00744"></a>00744 {
<a name="l00745"></a>00745   <span class="keywordtype">int</span> c, i;
<a name="l00746"></a>00746   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = 0; 
<a name="l00747"></a>00747 
<a name="l00748"></a>00748   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) 
<a name="l00749"></a>00749     {    
<a name="l00750"></a>00750       c = getc(fp);
<a name="l00751"></a>00751       <span class="keywordflow">if</span> (c == EOF) 
<a name="l00752"></a>00752         <span class="keywordflow">return</span> 0;
<a name="l00753"></a>00753       x = (x &lt;&lt; 8) | c; 
<a name="l00754"></a>00754     }    
<a name="l00755"></a>00755   <span class="keywordflow">return</span> x;
<a name="l00756"></a>00756 }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 <span class="comment">/* Try to either setup on-demand paging (using FP as backing</span>
<a name="l00759"></a>00759 <span class="comment">   file), or in case that doesn&#39;t work (FP not seekable) slurps in</span>
<a name="l00760"></a>00760 <span class="comment">   all pages and deactivates paging.  */</span>
<a name="l00761"></a>00761 <span class="keywordtype">int</span>
<a name="l00762"></a><a class="code" href="repopage_8h.html#a0571dc1902d4f46bb7f56b87bfefe39a">00762</a> <a class="code" href="repopage_8c.html#a0571dc1902d4f46bb7f56b87bfefe39a">repopagestore_read_or_setup_pages</a>(<a class="code" href="struct__Repopagestore.html">Repopagestore</a> *<a class="code" href="struct__Repodata.html#a113137114fabb8455b51679000ab7b4f">store</a>, FILE *<a class="code" href="struct__Repodata.html#aa5c124481775bbfc515a3bb422e20e4a">fp</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pagesz, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> blobsz)
<a name="l00763"></a>00763 {
<a name="l00764"></a>00764   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> npages;
<a name="l00765"></a>00765   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00766"></a>00766   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> can_seek;
<a name="l00767"></a>00767   <span class="keywordtype">long</span> cur_file_ofs;
<a name="l00768"></a>00768   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[BLOB_PAGESIZE];
<a name="l00769"></a>00769 
<a name="l00770"></a>00770   <span class="keywordflow">if</span> (pagesz != <a class="code" href="repopage_8h.html#afe3da5b5f40a2d44c9c5c7c75b2703d7">BLOB_PAGESIZE</a>)
<a name="l00771"></a>00771     {
<a name="l00772"></a>00772       <span class="comment">/* We could handle this by slurping in everything.  */</span>
<a name="l00773"></a>00773       <span class="keywordflow">return</span> SOLV_ERROR_CORRUPT;
<a name="l00774"></a>00774     }
<a name="l00775"></a>00775   can_seek = 1;
<a name="l00776"></a>00776   <span class="keywordflow">if</span> ((cur_file_ofs = ftell(fp)) &lt; 0)
<a name="l00777"></a>00777     can_seek = 0;
<a name="l00778"></a>00778   clearerr(fp);
<a name="l00779"></a>00779   <span class="keywordflow">if</span> (can_seek)
<a name="l00780"></a>00780     store-&gt;<a class="code" href="struct__Repopagestore.html#a7e713db342d0fa9da389b62a39dc5532">pagefd</a> = dup(fileno(fp));
<a name="l00781"></a>00781   <span class="keywordflow">if</span> (store-&gt;<a class="code" href="struct__Repopagestore.html#a7e713db342d0fa9da389b62a39dc5532">pagefd</a> == -1)
<a name="l00782"></a>00782     can_seek = 0;
<a name="l00783"></a>00783   <span class="keywordflow">else</span>
<a name="l00784"></a>00784     fcntl(store-&gt;<a class="code" href="struct__Repopagestore.html#a7e713db342d0fa9da389b62a39dc5532">pagefd</a>, F_SETFD, FD_CLOEXEC);
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 <span class="preprocessor">#ifdef DEBUG_PAGING</span>
<a name="l00787"></a>00787 <span class="preprocessor"></span>  fprintf(stderr, <span class="stringliteral">&quot;can %sseek\n&quot;</span>, can_seek ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;NOT &quot;</span>);
<a name="l00788"></a>00788 <span class="preprocessor">#endif</span>
<a name="l00789"></a>00789 <span class="preprocessor"></span>  npages = (blobsz + <a class="code" href="repopage_8h.html#afe3da5b5f40a2d44c9c5c7c75b2703d7">BLOB_PAGESIZE</a> - 1) / <a class="code" href="repopage_8h.html#afe3da5b5f40a2d44c9c5c7c75b2703d7">BLOB_PAGESIZE</a>;
<a name="l00790"></a>00790 
<a name="l00791"></a>00791   store-&gt;<a class="code" href="struct__Repopagestore.html#aff14ccd075cd605113a13cbd2b9c44e2">num_pages</a> = npages;
<a name="l00792"></a>00792   store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a> = <a class="code" href="util_8c.html#ab9d2d14a104453bab5b20a3e449db52b">sat_malloc2</a>(npages, <span class="keyword">sizeof</span>(store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a>[0]));
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   <span class="comment">/* If we can&#39;t seek on our input we have to slurp in everything.  */</span>
<a name="l00795"></a>00795   <span class="keywordflow">if</span> (!can_seek)
<a name="l00796"></a>00796     store-&gt;<a class="code" href="struct__Repopagestore.html#a88e253d812362cc8fce8acac68a4eab2">blob_store</a> = <a class="code" href="util_8c.html#ab9d2d14a104453bab5b20a3e449db52b">sat_malloc2</a>(npages, <a class="code" href="repopage_8h.html#afe3da5b5f40a2d44c9c5c7c75b2703d7">BLOB_PAGESIZE</a>);
<a name="l00797"></a>00797   <span class="keywordflow">for</span> (i = 0; i &lt; npages; i++)
<a name="l00798"></a>00798     {
<a name="l00799"></a>00799       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> in_len = <a class="code" href="repopage_8c.html#a9042a13324d3cbd2f5f24453913e5894">read_u32</a>(fp);
<a name="l00800"></a>00800       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> compressed = in_len &amp; 1;
<a name="l00801"></a>00801       <a class="code" href="struct__Attrblobpage.html">Attrblobpage</a> *p = store-&gt;<a class="code" href="struct__Repopagestore.html#add28ba834e627cd2ad3b48e717f81cc5">pages</a> + i;
<a name="l00802"></a>00802       in_len &gt;&gt;= 1;
<a name="l00803"></a>00803 <span class="preprocessor">#ifdef DEBUG_PAGING</span>
<a name="l00804"></a>00804 <span class="preprocessor"></span>      fprintf(stderr, <span class="stringliteral">&quot;page %d: len %d (%scompressed)\n&quot;</span>,
<a name="l00805"></a>00805                i, in_len, compressed ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>);
<a name="l00806"></a>00806 <span class="preprocessor">#endif</span>
<a name="l00807"></a>00807 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (can_seek)
<a name="l00808"></a>00808         {
<a name="l00809"></a>00809           cur_file_ofs += 4;
<a name="l00810"></a>00810           p-&gt;<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a> = -1;
<a name="l00811"></a>00811           p-&gt;<a class="code" href="struct__Attrblobpage.html#aa0fe8564583ab2317a87d96400f592b7">file_offset</a> = cur_file_ofs;
<a name="l00812"></a>00812           p-&gt;<a class="code" href="struct__Attrblobpage.html#aa73d3dcc10ba04a20dfc690013300907">file_size</a> = in_len * 2 + compressed;
<a name="l00813"></a>00813           <span class="keywordflow">if</span> (fseek(fp, in_len, SEEK_CUR) &lt; 0)
<a name="l00814"></a>00814             {
<a name="l00815"></a>00815               <span class="comment">/* We can&#39;t fall back to non-seeking behaviour as we already</span>
<a name="l00816"></a>00816 <span class="comment">                 read over some data pages without storing them away.  */</span>
<a name="l00817"></a>00817               close(store-&gt;<a class="code" href="struct__Repopagestore.html#a7e713db342d0fa9da389b62a39dc5532">pagefd</a>);
<a name="l00818"></a>00818               store-&gt;<a class="code" href="struct__Repopagestore.html#a7e713db342d0fa9da389b62a39dc5532">pagefd</a> = -1;
<a name="l00819"></a>00819               <span class="keywordflow">return</span> SOLV_ERROR_EOF;
<a name="l00820"></a>00820             }
<a name="l00821"></a>00821           cur_file_ofs += in_len;
<a name="l00822"></a>00822         }
<a name="l00823"></a>00823       <span class="keywordflow">else</span>
<a name="l00824"></a>00824         {
<a name="l00825"></a>00825           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> out_len;
<a name="l00826"></a>00826           <span class="keywordtype">void</span> *dest = store-&gt;<a class="code" href="struct__Repopagestore.html#a88e253d812362cc8fce8acac68a4eab2">blob_store</a> + i * BLOB_PAGESIZE;
<a name="l00827"></a>00827           p-&gt;<a class="code" href="struct__Attrblobpage.html#a2e27de4bfd5a40888cc08db1138f29bd">mapped_at</a> = i * BLOB_PAGESIZE;
<a name="l00828"></a>00828           p-&gt;<a class="code" href="struct__Attrblobpage.html#aa0fe8564583ab2317a87d96400f592b7">file_offset</a> = 0;
<a name="l00829"></a>00829           p-&gt;<a class="code" href="struct__Attrblobpage.html#aa73d3dcc10ba04a20dfc690013300907">file_size</a> = 0;
<a name="l00830"></a>00830           <span class="comment">/* We can&#39;t seek, so suck everything in.  */</span>
<a name="l00831"></a>00831           <span class="keywordflow">if</span> (fread(compressed ? buf : dest, in_len, 1, fp) != 1)
<a name="l00832"></a>00832             {
<a name="l00833"></a>00833               perror(<span class="stringliteral">&quot;fread&quot;</span>);
<a name="l00834"></a>00834               <span class="keywordflow">return</span> SOLV_ERROR_EOF;
<a name="l00835"></a>00835             }
<a name="l00836"></a>00836           <span class="keywordflow">if</span> (compressed)
<a name="l00837"></a>00837             {
<a name="l00838"></a>00838               out_len = <a class="code" href="repodata_8c.html#acaff5763966269b0341bf6a38fbb401f">unchecked_decompress_buf</a>(buf, in_len, dest, BLOB_PAGESIZE);
<a name="l00839"></a>00839               <span class="keywordflow">if</span> (out_len != BLOB_PAGESIZE &amp;&amp; i &lt; npages - 1)
<a name="l00840"></a>00840                 {
<a name="l00841"></a>00841                   <span class="keywordflow">return</span> SOLV_ERROR_CORRUPT;
<a name="l00842"></a>00842                 }
<a name="l00843"></a>00843             }
<a name="l00844"></a>00844         }
<a name="l00845"></a>00845     }
<a name="l00846"></a>00846   <span class="keywordflow">return</span> 0;
<a name="l00847"></a>00847 }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849 <span class="keywordtype">void</span>
<a name="l00850"></a><a class="code" href="repopage_8h.html#abe56dd47a2add4dbefa3c2e34e54d8dc">00850</a> <a class="code" href="repopage_8c.html#abe56dd47a2add4dbefa3c2e34e54d8dc">repopagestore_disable_paging</a>(<a class="code" href="struct__Repopagestore.html">Repopagestore</a> *<a class="code" href="struct__Repodata.html#a113137114fabb8455b51679000ab7b4f">store</a>)
<a name="l00851"></a>00851 {
<a name="l00852"></a>00852   <span class="keywordflow">if</span> (store-&gt;<a class="code" href="struct__Repopagestore.html#aff14ccd075cd605113a13cbd2b9c44e2">num_pages</a>)
<a name="l00853"></a>00853     <a class="code" href="repopage_8c.html#a5e983087e39e3cc9321aef3c13527460">repopagestore_load_page_range</a>(store, 0, store-&gt;<a class="code" href="struct__Repopagestore.html#aff14ccd075cd605113a13cbd2b9c44e2">num_pages</a> - 1);
<a name="l00854"></a>00854 }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856 <span class="preprocessor">#ifdef STANDALONE</span>
<a name="l00857"></a>00857 <span class="preprocessor"></span>
<a name="l00858"></a>00858 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00859"></a>00859 transfer_file(FILE * from, FILE * to, <span class="keywordtype">int</span> compress)
<a name="l00860"></a>00860 {
<a name="l00861"></a>00861   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> inb[BLOCK_SIZE];
<a name="l00862"></a>00862   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> outb[BLOCK_SIZE];
<a name="l00863"></a>00863   <span class="keywordflow">while</span> (!feof (from) &amp;&amp; !ferror (from))
<a name="l00864"></a>00864     {
<a name="l00865"></a>00865       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> in_len, out_len;
<a name="l00866"></a>00866       <span class="keywordflow">if</span> (compress)
<a name="l00867"></a>00867         {
<a name="l00868"></a>00868           in_len = fread(inb, 1, <a class="code" href="repopage_8c.html#ad51ded0bbd705f02f73fc60c0b721ced">BLOCK_SIZE</a>, from);
<a name="l00869"></a>00869           <span class="keywordflow">if</span> (in_len)
<a name="l00870"></a>00870             {
<a name="l00871"></a>00871               <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *b = outb;
<a name="l00872"></a>00872               out_len = <a class="code" href="repodata_8c.html#a02d45a8e61f3d30e42080e65d267dfcc">compress_buf</a>(inb, in_len, outb, <span class="keyword">sizeof</span> (outb));
<a name="l00873"></a>00873               <span class="keywordflow">if</span> (!out_len)
<a name="l00874"></a>00874                 b = inb, out_len = in_len;
<a name="l00875"></a>00875               <span class="keywordflow">if</span> (fwrite(&amp;out_len, <span class="keyword">sizeof</span> (out_len), 1, to) != 1)
<a name="l00876"></a>00876                 {
<a name="l00877"></a>00877                   perror(<span class="stringliteral">&quot;write size&quot;</span>);
<a name="l00878"></a>00878                   exit (1);
<a name="l00879"></a>00879                 }
<a name="l00880"></a>00880               <span class="keywordflow">if</span> (fwrite(b, out_len, 1, to) != 1)
<a name="l00881"></a>00881                 {
<a name="l00882"></a>00882                   perror(<span class="stringliteral">&quot;write data&quot;</span>);
<a name="l00883"></a>00883                   exit (1);
<a name="l00884"></a>00884                 }
<a name="l00885"></a>00885             }
<a name="l00886"></a>00886         }
<a name="l00887"></a>00887       <span class="keywordflow">else</span>
<a name="l00888"></a>00888         {
<a name="l00889"></a>00889           <span class="keywordflow">if</span> (fread(&amp;in_len, <span class="keyword">sizeof</span>(in_len), 1, from) != 1)
<a name="l00890"></a>00890             {
<a name="l00891"></a>00891               <span class="keywordflow">if</span> (feof(from))
<a name="l00892"></a>00892                 <span class="keywordflow">return</span>;
<a name="l00893"></a>00893               perror(<span class="stringliteral">&quot;can&#39;t read size&quot;</span>);
<a name="l00894"></a>00894               exit(1);
<a name="l00895"></a>00895             }
<a name="l00896"></a>00896           <span class="keywordflow">if</span> (fread(inb, in_len, 1, from) != 1)
<a name="l00897"></a>00897             {
<a name="l00898"></a>00898               perror(<span class="stringliteral">&quot;can&#39;t read data&quot;</span>);
<a name="l00899"></a>00899               exit(1);
<a name="l00900"></a>00900             }
<a name="l00901"></a>00901           out_len =
<a name="l00902"></a>00902             <a class="code" href="repodata_8c.html#acaff5763966269b0341bf6a38fbb401f">unchecked_decompress_buf</a>(inb, in_len, outb, <span class="keyword">sizeof</span>(outb));
<a name="l00903"></a>00903           <span class="keywordflow">if</span> (fwrite(outb, out_len, 1, to) != 1)
<a name="l00904"></a>00904             {
<a name="l00905"></a>00905               perror(<span class="stringliteral">&quot;can&#39;t write output&quot;</span>);
<a name="l00906"></a>00906               exit(1);
<a name="l00907"></a>00907             }
<a name="l00908"></a>00908         }
<a name="l00909"></a>00909     }
<a name="l00910"></a>00910 }
<a name="l00911"></a>00911 
<a name="l00912"></a>00912 <span class="comment">/* Just for benchmarking purposes.  */</span>
<a name="l00913"></a>00913 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00914"></a>00914 dumb_memcpy(<span class="keywordtype">void</span> *dest, <span class="keyword">const</span> <span class="keywordtype">void</span> *src, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len)
<a name="l00915"></a>00915 {
<a name="l00916"></a>00916   <span class="keywordtype">char</span> *d = dest;
<a name="l00917"></a>00917   <span class="keyword">const</span> <span class="keywordtype">char</span> *s = src;
<a name="l00918"></a>00918   <span class="keywordflow">while</span> (len--)
<a name="l00919"></a>00919     *d++ = *s++;
<a name="l00920"></a>00920 }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00923"></a>00923 benchmark(FILE * from)
<a name="l00924"></a>00924 {
<a name="l00925"></a>00925   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> inb[BLOCK_SIZE];
<a name="l00926"></a>00926   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> outb[BLOCK_SIZE];
<a name="l00927"></a>00927   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> in_len = fread(inb, 1, <a class="code" href="repopage_8c.html#ad51ded0bbd705f02f73fc60c0b721ced">BLOCK_SIZE</a>, from);
<a name="l00928"></a>00928   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> out_len;
<a name="l00929"></a>00929   <span class="keywordflow">if</span> (!in_len)
<a name="l00930"></a>00930     {
<a name="l00931"></a>00931       perror(<span class="stringliteral">&quot;can&#39;t read from input&quot;</span>);
<a name="l00932"></a>00932       exit(1);
<a name="l00933"></a>00933     }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> calib_loop;
<a name="l00936"></a>00936   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> per_loop;
<a name="l00937"></a>00937   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
<a name="l00938"></a>00938   clock_t <a class="code" href="struct__Repodata.html#a4511574292e484437fd7eca03f74b41f">start</a>, <a class="code" href="struct__Repodata.html#a79054fe8102a97d5b6f79470764a281d">end</a>;
<a name="l00939"></a>00939   <span class="keywordtype">float</span> seconds;
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 <span class="preprocessor">#if 0</span>
<a name="l00942"></a>00942 <span class="preprocessor"></span>  calib_loop = 1;
<a name="l00943"></a>00943   per_loop = 0;
<a name="l00944"></a>00944   start = clock();
<a name="l00945"></a>00945   <span class="keywordflow">while</span> ((clock() - start) &lt; CLOCKS_PER_SEC / 4)
<a name="l00946"></a>00946     {
<a name="l00947"></a>00947       calib_loop *= 2;
<a name="l00948"></a>00948       <span class="keywordflow">for</span> (i = 0; i &lt; calib_loop; i++)
<a name="l00949"></a>00949         dumb_memcpy(outb, inb, in_len);
<a name="l00950"></a>00950       per_loop += calib_loop;
<a name="l00951"></a>00951     }
<a name="l00952"></a>00952 
<a name="l00953"></a>00953   fprintf(stderr, <span class="stringliteral">&quot;memcpy:\nCalibrated to %d iterations per loop\n&quot;</span>,
<a name="l00954"></a>00954            per_loop);
<a name="l00955"></a>00955 
<a name="l00956"></a>00956   start = clock();
<a name="l00957"></a>00957   <span class="keywordflow">for</span> (i = 0; i &lt; 10; i++)
<a name="l00958"></a>00958     <span class="keywordflow">for</span> (j = 0; j &lt; per_loop; j++)
<a name="l00959"></a>00959       dumb_memcpy(outb, inb, in_len);
<a name="l00960"></a>00960   end = clock();
<a name="l00961"></a>00961   seconds = (end - start) / (<span class="keywordtype">float</span>) CLOCKS_PER_SEC;
<a name="l00962"></a>00962   fprintf(stderr, <span class="stringliteral">&quot;%.2f seconds == %.2f MB/s\n&quot;</span>, seconds,
<a name="l00963"></a>00963            ((<span class="keywordtype">long</span> <span class="keywordtype">long</span>) in_len * per_loop * 10) / (1024 * 1024 * seconds));
<a name="l00964"></a>00964 <span class="preprocessor">#endif</span>
<a name="l00965"></a>00965 <span class="preprocessor"></span>
<a name="l00966"></a>00966   calib_loop = 1;
<a name="l00967"></a>00967   per_loop = 0;
<a name="l00968"></a>00968   start = clock();
<a name="l00969"></a>00969   <span class="keywordflow">while</span> ((clock() - start) &lt; CLOCKS_PER_SEC / 4)
<a name="l00970"></a>00970     {
<a name="l00971"></a>00971       calib_loop *= 2;
<a name="l00972"></a>00972       <span class="keywordflow">for</span> (i = 0; i &lt; calib_loop; i++)
<a name="l00973"></a>00973         <a class="code" href="repodata_8c.html#a02d45a8e61f3d30e42080e65d267dfcc">compress_buf</a>(inb, in_len, outb, <span class="keyword">sizeof</span>(outb));
<a name="l00974"></a>00974       per_loop += calib_loop;
<a name="l00975"></a>00975     }
<a name="l00976"></a>00976 
<a name="l00977"></a>00977   fprintf(stderr, <span class="stringliteral">&quot;compression:\nCalibrated to %d iterations per loop\n&quot;</span>,
<a name="l00978"></a>00978            per_loop);
<a name="l00979"></a>00979 
<a name="l00980"></a>00980   start = clock();
<a name="l00981"></a>00981   <span class="keywordflow">for</span> (i = 0; i &lt; 10; i++)
<a name="l00982"></a>00982     <span class="keywordflow">for</span> (j = 0; j &lt; per_loop; j++)
<a name="l00983"></a>00983       <a class="code" href="repodata_8c.html#a02d45a8e61f3d30e42080e65d267dfcc">compress_buf</a>(inb, in_len, outb, <span class="keyword">sizeof</span>(outb));
<a name="l00984"></a>00984   end = clock();
<a name="l00985"></a>00985   seconds = (end - start) / (<span class="keywordtype">float</span>) CLOCKS_PER_SEC;
<a name="l00986"></a>00986   fprintf(stderr, <span class="stringliteral">&quot;%.2f seconds == %.2f MB/s\n&quot;</span>, seconds,
<a name="l00987"></a>00987            ((<span class="keywordtype">long</span> <span class="keywordtype">long</span>) in_len * per_loop * 10) / (1024 * 1024 * seconds));
<a name="l00988"></a>00988 
<a name="l00989"></a>00989   out_len = <a class="code" href="repodata_8c.html#a02d45a8e61f3d30e42080e65d267dfcc">compress_buf</a>(inb, in_len, outb, <span class="keyword">sizeof</span>(outb));
<a name="l00990"></a>00990 
<a name="l00991"></a>00991   calib_loop = 1;
<a name="l00992"></a>00992   per_loop = 0;
<a name="l00993"></a>00993   start = clock();
<a name="l00994"></a>00994   <span class="keywordflow">while</span> ((clock() - start) &lt; CLOCKS_PER_SEC / 4)
<a name="l00995"></a>00995     {
<a name="l00996"></a>00996       calib_loop *= 2;
<a name="l00997"></a>00997       <span class="keywordflow">for</span> (i = 0; i &lt; calib_loop; i++)
<a name="l00998"></a>00998         <a class="code" href="repodata_8c.html#acaff5763966269b0341bf6a38fbb401f">unchecked_decompress_buf</a>(outb, out_len, inb, <span class="keyword">sizeof</span>(inb));
<a name="l00999"></a>00999       per_loop += calib_loop;
<a name="l01000"></a>01000     }
<a name="l01001"></a>01001 
<a name="l01002"></a>01002   fprintf(stderr, <span class="stringliteral">&quot;decompression:\nCalibrated to %d iterations per loop\n&quot;</span>,
<a name="l01003"></a>01003            per_loop);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005   start = clock();
<a name="l01006"></a>01006   <span class="keywordflow">for</span> (i = 0; i &lt; 10; i++)
<a name="l01007"></a>01007     <span class="keywordflow">for</span> (j = 0; j &lt; per_loop; j++)
<a name="l01008"></a>01008       <a class="code" href="repodata_8c.html#acaff5763966269b0341bf6a38fbb401f">unchecked_decompress_buf</a>(outb, out_len, inb, <span class="keyword">sizeof</span>(inb));
<a name="l01009"></a>01009   end = clock();
<a name="l01010"></a>01010   seconds = (end - start) / (<span class="keywordtype">float</span>) CLOCKS_PER_SEC;
<a name="l01011"></a>01011   fprintf(stderr, <span class="stringliteral">&quot;%.2f seconds == %.2f MB/s\n&quot;</span>, seconds,
<a name="l01012"></a>01012            ((<span class="keywordtype">long</span> <span class="keywordtype">long</span>) in_len * per_loop * 10) / (1024 * 1024 * seconds));
<a name="l01013"></a>01013 }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015 <span class="keywordtype">int</span>
<a name="l01016"></a>01016 main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
<a name="l01017"></a>01017 {
<a name="l01018"></a>01018   <span class="keywordtype">int</span> compress = 1;
<a name="l01019"></a>01019   <span class="keywordflow">if</span> (argc &gt; 1 &amp;&amp; !strcmp(argv[1], <span class="stringliteral">&quot;-d&quot;</span>))
<a name="l01020"></a>01020     compress = 0;
<a name="l01021"></a>01021   <span class="keywordflow">if</span> (argc &gt; 1 &amp;&amp; !strcmp(argv[1], <span class="stringliteral">&quot;-b&quot;</span>))
<a name="l01022"></a>01022     benchmark(stdin);
<a name="l01023"></a>01023   <span class="keywordflow">else</span>
<a name="l01024"></a>01024     transfer_file(stdin, stdout, compress);
<a name="l01025"></a>01025   <span class="keywordflow">return</span> 0;
<a name="l01026"></a>01026 }
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 <span class="preprocessor">#endif</span>
<a name="l01029"></a>01029 <span class="preprocessor"></span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Oct 17 2010 15:21:22 for satsolver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
