<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>satsolver: All about attributes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>All about attributes </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="attr-why"></a>
Why attributes ?</h2>
<p>The .solv files contain Solvables, as defined in <a class="el" href="solvable_8h.html">src/solvable.h</a> These are the basic objects for the solver, containing name, architecture, evr (epoch-version-release), vendor and dependencies.</p>
<p>However, a (RPM) package has many more properties. Like summary, description, license, package group, etc. All theses properties are not needed for dependency resolution and hence are stored outside of Solvables.</p>
<p>Sat-solver provides the 'Attribute Store' for these properties, internally called 'repodata'. See <a class="el" href="repodata_8h.html">src/repodata.h</a></p>
<h2><a class="anchor" id="attr-what"></a>
What are attributes ?</h2>
<p>An attribute is a quadruple containing</p>
<ul>
<li>solvable (to which this attribute belongs)</li>
<li>name (describing the content, like 'solvable:description')</li>
<li>type (like 'number' or 'string')</li>
<li>value (according to the type)</li>
</ul>
<h2><a class="anchor" id="attr-how"></a>
How to set attributes ?</h2>
<h3><a class="anchor" id="attr-how-solvable"></a>
You need a Solvable</h3>
<p>Attributes belong to a solvable. So you need a solvable first. And solvables belong to a repo which belongs to a pool.</p>
<div class="fragment"><pre class="fragment">    <span class="comment">/* create a pool */</span>
    <a class="code" href="struct__Pool.html">Pool</a> *pool = <a class="code" href="pool_8c.html#a6e3f022987f2ea6885bd43733f2fc87f" title="Creates a new pool.">pool_create</a>();
    
    <span class="comment">/* create a repo */</span>
    <a class="code" href="struct__Repo.html">Repo</a> *repo = <a class="code" href="repo_8c.html#ae5a3b44b83bd16c07c41124432c97c84">repo_create</a>(pool, <span class="stringliteral">&quot;demo&quot;</span>);
    
    <span class="comment">/* create a solvable */</span>
    <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a> s = <a class="code" href="repo_8h.html#a3903f2c0056b12d2f508f2ca0667033e">repo_add_solvable</a>(repo);
</pre></div><h3><a class="anchor" id="attr-how-create"></a>
You need to create the attribute store</h3>
<p>By default .solv files don't contain additional attributes. So you have to add the attribute store to the repository:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="struct__Repodata.html">Repodata</a> *data = <a class="code" href="repo_8c.html#a26e7469a89ef78156d6a09ca4333909a">repo_add_repodata</a>(repo, 0);
</pre></div><p>The second parameter indicates a 'local pool' for storing strings. By default, strings are stored in the Pool. Setting the second parameter to non-zero will store attribute string values separate from the Pool.</p>
<p>[Q: Whats the technical reason for the local pool?]</p>
<h3><a class="anchor" id="attr-how-space"></a>
You need space for the attributes</h3>
<p>Space for the attribute store must be explicitly requested. Not for every attribute but you have to signal that a solvable has attributes.</p>
<p>First you compute the datanum:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="struct__Solvable.html">Solvable</a> *solvable = <a class="code" href="pool_8h.html#a916e27b2c000914070fc207dd5b754e1">pool_id2solvable</a>(pool, s);
    <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a> datanum = (solvable - pool-&gt;<a class="code" href="struct__Pool.html#a9842c936aa241bad13ba13f21a337319">solvables</a>) - repo-&gt;<a class="code" href="struct__Repo.html#a4eb2dd93e4a4f88f13d462f2f111e038">start</a>;
</pre></div><p>datanum is the reference from the attribute store back to the solvable.</p>
<p>As you can see, the datanum is basically the offset of the solvable within the repo. Remember that the attributes are per-repository (as is the solvable. When calling 'repodata_*' function, use the datanum to represent the solvable.</p>
<p>Extending the store is done with <a class="el" href="repodata_8c.html#a09aaffa2499f5634224be763bd952c9e">repodata_extend()</a>:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="repodata_8c.html#a09aaffa2499f5634224be763bd952c9e">repodata_extend</a>(data, solvable - pool-&gt;<a class="code" href="struct__Pool.html#a9842c936aa241bad13ba13f21a337319">solvables</a>);
</pre></div><p>[Q: The offset passed to repodata_extend is per-pool. All other repodata functions are per-repo. Why ?]</p>
<h3><a class="anchor" id="attr-how-set"></a>
Set attributes</h3>
<p>Now you can set attributes. You do this with repodata_set_*() passing the store (data), the solvable reference (datanum), the name of the solvable and the value.</p>
<p>See <a class="el" href="repodata_8h.html">src/repodata.h</a> for a complete list of all the repodata_set_*() functions.</p>
<p>Attributes are named and in good sat-solver tradition, everything is an Id.</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a> attr_name = <a class="code" href="poolid_8c.html#ad7352e5986a8eb7bb5fdf0158f445a09">str2id</a>(pool, <span class="stringliteral">&quot;name_of_attribute&quot;</span>, 1);
</pre></div><p>See <a class="el" href="knownid_8h.html">knownid.h</a> for predefined attribute names.</p>
<h4><a class="anchor" id="attr-how-set-bool"></a>
Setting a boolean attribute</h4>
<p>A boolean attribute derives is value from its presence. So you don't pass an explicit true/false value but call <a class="el" href="repodata_8c.html#a39a25ae69c8b2b24edd886b13d6a6704">repodata_set_void()</a> if the attribute is 'true'.</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="repodata_8c.html#a39a25ae69c8b2b24edd886b13d6a6704">repodata_set_void</a>(data, datanum, attr_name);
</pre></div><h4><a class="anchor" id="attr-how-set-num"></a>
Setting a numeric attribute</h4>
<p>Storing a numeric value is done with repodata_set_num, passing an unsinged integer:</p>
<p>unsigned int value = 123456; repodata_set_num(data, datanum, attr_name, value);</p>
<h4><a class="anchor" id="attr-how-set-str"></a>
Setting a string attribute</h4>
<p>Strings are 'const char' pointers and set like:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">const</span> <span class="keywordtype">char</span> *s = <span class="stringliteral">&quot;This is a string&quot;</span>;
    <a class="code" href="repodata_8c.html#a86db20fb2dbb1e77df6e6acf16f82fcc">repodata_set_str</a>(data, datanum, attr_name, s);
</pre></div><p>If the same string is used multiple times as an attribute value, its more efficient to store it once and use its Id.</p>
<h4><a class="anchor" id="attr-how-set-id"></a>
Setting an Id attribute</h4>
<div class="fragment"><pre class="fragment">    <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a> <span class="keywordtype">id</span> = <a class="code" href="poolid_8c.html#ad7352e5986a8eb7bb5fdf0158f445a09">str2id</a>(pool, <span class="stringliteral">&quot;value_of_attribute&quot;</span>, 1);
    <a class="code" href="repodata_8c.html#a554f75abef2ce51097d9751c88b8dcf5">repodata_set_id</a>(data, datanum, attr_name, <span class="keywordtype">id</span>);
</pre></div><h4><a class="anchor" id="attr-how-set-const"></a>
Setting a constant attribute</h4>
<p>A constant attribute shares a single value across all instances of the attribute.</p>
<p>A constant can either be of numeric (unsigned int) type</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="repodata_8c.html#a44a22b6f1d5c91c01324da6431be913b">repodata_set_constant</a>(data, datanum, attr_name, 12345);
</pre></div><p>or an Id:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a> <span class="keywordtype">id</span> = <a class="code" href="poolid_8c.html#ad7352e5986a8eb7bb5fdf0158f445a09">str2id</a>(pool, <span class="stringliteral">&quot;constant string&quot;</span>, 1);
    <a class="code" href="repodata_8c.html#a44a22b6f1d5c91c01324da6431be913b">repodata_set_constant</a>(data, datanum, attr_name, <span class="keywordtype">id</span>);
</pre></div><h4><a class="anchor" id="attr-how-set-array"></a>
Arrays</h4>
<p>Sometimes an attribute doesn't have a single value, but a varying number of values. Here arrays come in handy.</p>
<p>The attribute store knows about two types of arrays. Arrays of Ids and arrays of strings.</p>
<p>You fill an array by multiple calls to (array of Ids)</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="repodata_8c.html#a057be60a05140be7bd34954fa03871d3">repodata_add_idarray</a>(data, datanum, attr_name, <span class="keywordtype">id</span>)
</pre></div><p>or</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="repodata_8c.html#ac0ffb3e5c8122e20ad5907bbefc5131d">repodata_add_poolstr_array</a>(data, datanum, attr_name, <span class="stringliteral">&quot;value&quot;</span>)
</pre></div><p>Every call will add the value to the end of the array.</p>
<p>[Q: can I mix Id and char* in one array ?]</p>
<h4><a class="anchor" id="attr-how-set-other"></a>
Other data types</h4>
<p>See <a class="el" href="repodata_8h.html">repodata.h</a>, there are</p>
<ul>
<li>checksum</li>
<li>bin_checksum</li>
<li>dirnumnum</li>
<li>dirstr</li>
</ul>
<h4><a class="anchor" id="attr-how-set-struct"></a>
Structural attribute types</h4>
<p>Structural attribute types are (currently) not supported.</p>
<h3><a class="anchor" id="attr-how-write-solv"></a>
Writing the .solv file</h3>
<p>Before writing out a .solv file, you need to internalize the attribute store so it gets stored together with the solvables.</p>
<p>repodata_internalize(data);</p>
<p>Thats black MM magic. Don't ask.</p>
<h3><a class="anchor" id="attr-how-read-attr"></a>
Reading attributes</h3>
<p>Reading attribute values isn't that easy because of the way they're stored internally. The storage optimization prevents a direct-access method, so you need to search for the value matching a specific solvable and attribute name.</p>
<p>Hence the read functions are called 'repodata_lookup_*()' and only exist for some attribute types, namely boolean (void), numeric, string, Id and bin_checksum.</p>
<p>The preparation steps are similar to writing, you need a pool, a repository and the solvable reference.</p>
<div class="fragment"><pre class="fragment">    <span class="comment">/* create a pool */</span>
    <a class="code" href="struct__Pool.html">Pool</a> *pool = <a class="code" href="pool_8c.html#a6e3f022987f2ea6885bd43733f2fc87f" title="Creates a new pool.">pool_create</a>();
    
    <span class="comment">/* create a repo */</span>
    <a class="code" href="struct__Repo.html">Repo</a> *repo = <a class="code" href="repo_8c.html#ae5a3b44b83bd16c07c41124432c97c84">repo_create</a>(pool, <span class="stringliteral">&quot;demo&quot;</span>);
    
    <a class="code" href="struct__Solvable.html">Solvable</a> *s;

    <span class="comment">/*</span>
<span class="comment"> now populate the repo</span>
<span class="comment"> either from a .solv file: repo_add_solv(Repo *, FILE *);</span>
<span class="comment"> or from the RPM database: repo_add_rpmdb(Repo *, NULL, &quot;/&quot;);</span>
<span class="comment"></span>
<span class="comment"> and retrieve a Solvable s</span>
<span class="comment"></span>
<span class="comment">     */</span>
</pre></div><h3><a class="anchor" id="attr-how-read-known"></a>
Reading known attributes</h3>
<p>For the standard attribute names as listed in <a class="el" href="knownid_8h.html">knownid.h</a>, the easiest way to retrieve values it through repo_lookup_*() (as opposed to repodata_lookup_*())</p>
<div class="fragment"><pre class="fragment">    <span class="comment">/* get the summary attribute */</span>
    <span class="keyword">const</span> <span class="keywordtype">char</span> *summary = <a class="code" href="repo_8c.html#a3400ff5da984ddb3a8c410422c8b3c49">repo_lookup_str</a>(s, SOLVABLE_SUMMARY);

    <span class="comment">/* get the buildtime attribute */</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> buildtime = <a class="code" href="repo_8c.html#a6c0b10c58941f727743a9ffd32b1c0cf">repo_lookup_num</a>(s, SOLVABLE_BUILDTIME);
</pre></div><p>Both lookup functions return 0 if the attribute isn't set.</p>
<p>The downside of these simple access functions it that you have to know the type of the attribute you're going to retrieve.</p>
<h3><a class="anchor" id="attr-how-lookup-generic"></a>
Generic attribute lookup</h3>
<p>The function repo_lookup() provides a generic way to access attribute values. It is passed a solvable, an attribute name (as Id) and a callback function.</p>
<p>repo_lookup then tries to retrieve the attribute value and returns non-zero on success.</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="pooltypes_8h.html#a2e0e6278ac51842ca3aeb53e3fc3ead6">Id</a> attr_name = <a class="code" href="poolid_8c.html#ad7352e5986a8eb7bb5fdf0158f445a09">str2id</a>(pool, <span class="stringliteral">&quot;name_of_attribute&quot;</span>, 0);
</pre></div><p>You can also use predefined Ids from <a class="el" href="knownid_8h.html">knownid.h</a> Pay attention to the last parameter to the str2id call. It was 1 when setting the attribute buts its 0 when reading.</p>
<p>This is just a short-path to check for existance of an attribute (name). Passing 0 to str2id means 'do not create if not existing before'. So if attr_name is assigned 0 (ID_NULL) in this call, this attribute is not defined within the pool.</p>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span>(repo_lookup(s, attr_name, callback_function, (<span class="keywordtype">void</span> *)callback_data) {
    <span class="comment">/* attribute found */</span>
  }

  If the solvable s has the attribute attr_name defined, the
  callback_function is called passing callback_data.

  This function is defined as

    <span class="keywordtype">int</span> callback_function( <span class="keywordtype">void</span> *cbdata, <a class="code" href="struct__Solvable.html">Solvable</a> *s, <a class="code" href="struct__Repodata.html">Repodata</a> *data, <a class="code" href="struct__Repokey.html">Repokey</a> *key, <a class="code" href="struct__KeyValue.html">KeyValue</a> *kv )
</pre></div><p>with</p>
<p>cbdata: the callback_data from the call to repo_lookup s: the solvable from the call to repo_lookup data: the attribute store associated with the repo key: the attribute name (key-&gt;name, an Id) and type (key-&gt;type, a REPOKEY_TYPE_*) kv: the attribute value (depending on the key-&gt;type)</p>
<p>within the callback_function, you usually look at the key-&gt;type and access the value according to the type:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">switch</span>(key-&gt;<a class="code" href="struct__Repokey.html#a882a88f813ace5b37108fc92612ca799">type</a>)
    {
      <span class="keywordflow">case</span> REPOKEY_TYPE_VOID: <span class="comment">/* just existance */</span>
      ...
      <span class="keywordflow">break</span>;
      <span class="keywordflow">case</span> REPOKEY_TYPE_NUM:  <span class="comment">/* value is in kv-&gt;num */</span>
      ...
      <span class="keywordflow">break</span>;
      <span class="keywordflow">case</span> REPOKEY_TYPE_STR:  <span class="comment">/* value is in kv-&gt;str */</span>
      ...
      <span class="keywordflow">break</span>;
      
      <span class="comment">/* ... */</span>
    }
    <span class="keywordflow">return</span> 1;
</pre></div><p>Returning non-zero from the callback_function will end the lookup, signalling you've found what you were looking for.</p>
<h3><a class="anchor" id="attr-how-about-attr-name"></a>
About attribute names</h3>
<p>You are free to choose any name for the attributes. However, when dealing with (RPM) packages, there are a lot of standard attributes in use. <a class="el" href="knownid_8h.html">src/knownid.h</a> defines most of them, e.g. SOLVABLE_SUMMARY (a string) or SOLVABLE_BUILDTIME (a number). Use the predefined attribute names whenever applicable. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Oct 17 2010 15:21:23 for satsolver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
